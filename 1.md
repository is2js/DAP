# 1장 데이터 모델링

**\*\*\*데이터 모델의 정의** : **현실세계에 대해 `우리가 관심있어`하는 대상을 `데이터베이스화`하기 위한 개념적 도구**

**종류** : 

1. **개념 데이터 모델링** : 합참의장 - 참모총장 - 사령부 - ... - 사단까지 / 쉽게 생성 가능, 이후 논리부터 분해(상세화 된다)
   - 주제영역 정의 -> 주제영역내의 핵심엔터티(key, main) 도출 -> 그달간의 관계를 정의
2. **논리 데이터 모델링** : 대령 - 중령 - ... - 병장 까지 / Entity라 부름. 
3. **물리 데이터 모델링** : 각 DBMS의 기준에 맞추어서 논리 데이터 모델링을 전환한 것 / Table이라 부름.



**표기법** 

1. 바커 표기법 : `#` (key), `*`: mandatory, `o`: optional / `sub-type`을 내부에서 쉽게 표현, 속성은 최하위의 요소들 
2. 정보공학적 표기법 : SQLD에서 보던 표기법 / `subtype`작성은 밖에서 표현(X가 달린 것이 mandatory)



## 제 1절 데이터 모델링 이해

**IT 개발 방법론의 발전방향** : 

* 1970 구조적 방법론 :  프로그램 자체가 중요
* **1980 정보공학적 방법론(Information Engineering)** : 데이터가 중요
* 1990 CBD 방법론 : process + data 모두 중요. 



### 데이터 모델링 정의

1. 데이터 모델링 탄생 배경

   * **중복 없이** 정확하게 유지 ex> 반정규화로 속성을 갖다붙혀서 join안하는 것...은 중복이다..
   * 정확한 업무 파악(**데이터에 대한 정확한 분석**)
   * **현실세계** 잘 표현할 수 있을까?에 대한 답으로 **ERD**로 표현

2. **데이터 모델의 정의** : **현실세계에 대해 우리가 관심있어 하는 대상을 데이터베이스화하기 위한 개념적 도구**

3. 모델링의 정의

   * 실체를 나타내는 일과 **모형화**

   * 모델이란? 현실세계의 **추상화(=논리적 표현)**된 반영

   * **즉, 업무에 대한 종합적 이해를 바탕으로, 업무 규칙(Biz Rule)에 대해 참/거짓을 판별할 수 있는 사실을 정의. **

   * **어떻게(HOW), 누가(WHO) 접근하는지는 상관없다. (전산화랑 상관없다)**

   * **현 업무파악으로 문제점 인식  +  개선사항 도출 +  적합한 설계를 위해, 인간이 해야할 대부분의 결정을 내리는 단계까지 포함하는 것**

     **\*\*\*프로세스 = 나쁜말**

4. 데이터 모델이 제공하는 것 (-가, 명, 틀, 문, 관, 세-)

   - 시스템을 **가시화**
   - 시스템 구조와 행동을 **명세화**
   - 시스템 구축하는 틀 제공
   - 결정한 것을 **문서화**
   - 집중하기 위해 다른 영역의 세부사항을 숨기는 **다양한 관점** 제공(개괄 데이터 모델)
   - 목표에 따른 다양한 **상세수준 제공**

   **\*\*\*주제영역을 기점으로 **

   **`上 : 개괄 데이터 모델` / `內 : 핵심 엔터티 도출의 개념 데이터 모델` / `下 : 논리 데이터 모델`***

   

### 데이터 모델링 필요성

* 고품질 데이터 모델 -> **안정성, 유연성, 성능**에 영향 / 시스템 개발의 가장 **핵심적인 과정**

* **프로세스(세모)** 중심적인 시스템 구축 방법 -> **정보 공유 문제점 발생 / 데이터 무결성에 좋지 않음 / 데이터 품질에 악영향**
  ex> **프로세스별**로 따로 개발하게 되면 각 시스템마다 **`사원TABLE`이 따로 생기게 된다**.
         **정보의 고립화 / 데이터 중복 / 데이터 무결성 문제 발생**

  => 기능별 시스템을 가로지르는 **데이터 통합이 중요**

* 데이터 모델링(설계)가 중요한 이유

  1. **파급효과** : 테스트 시점에서의 변경은 많은 비용 초래
  2. **간결한** **표현** : 복잡한 현실세계를 간결한 DB로 표현 가능
  3. **데이터 품질**

가. 애플리케이션과 데이터의 통합

* 앱 코딩 차원의 통합은 많은 비용 초래
* **데이터 기반으로 한 통합이 필요** -> 효과적, 저비용, 안정적

나. 개발자들의 시스템 이해 

* 시스템+데이터의 확실한 이해를 위해, 데이터 모형화가 필요하다
  1. 사용자 관점 데이터 : 사용자가 원하는 것 : 논리적 개념 --> 시스템이 그것을 제공 : 물리적 개념
  2. 물리적 표현or사용에 관계없이 데이터 그자체가 본질이다.
     - 저장기법, 접근방법, 데이터사용자와 사용법과는 무관하게 데이터 자체가 본질

다. **\*\*\*데이터 모델링시 주의점(-중, 비, 비-)**

1. **중복(Duplication)**	

 	2. **비유연성(Inflexibility)** 
     ex> 처음부터 보험의 관계자를 3명만 설계(보험계약자, 피보험자1, 피보험자2)할 경우,  사람을 추가할 수 없다. 그러지 말고, `보험관계자`테이블을 따로 만들어  *관계유형 : 보험계약자 or 피보험자  으로 유연성있게 바꿀 수 있다.
 	3. **비일관성(Inconsistency)** : 여기는 있는데, 저기는 없는 경우



### 데이터 모델링 단계

1. `개념 데이터 모델링`
   - **주제영역 정의 : 부서를 나누는 것으로 생각하자.**
   - **주제영역내 핵심엔터티 도출 : key, main entity 도출**
   - **엔터티들간의 관계 정의**
2. **`논리 데이터 모델링`\*\*\*(- 속, 엔, 이-)(-엔 : 식, 정, M, 참)**
   - **속**성 정의
   - **엔**터티 상세화
     - **식**별자 확정
     - **정**규화
     - **M**:N 관계 제거
     - **참**조 무결성 정의
   - **이**력관리
3. **`물리 데이터 모델링`**
   - 물리 / 물리 / **변**환(논리에서 이미 비지니스 룰 다 반영, 물리에서는 변환만) / **반**정규화

### 모델링의 기본원칙

**\*\*\*(-커뮤니케이션, 모델링 상세화, 논리적표현-)**

1. **커뮤니케이션 원칙** : **ERD를 그려놓고 이야기**하면, 서로 다르게 이해하는 문제가 해결

2. **모델링 상세화 원칙** : 비즈니스 담당자와 **비즈니스 룰을 적용하여, 논리 데이터 모델링에서  다 끝**낸다. (물리 데이터 모델링의 TABLE과 상세수준이 같음)
   - 데이터 본질과 잠재적 사용을 이해할 수 있을 만큼 상세화
   - 논리 데이터 모델에서 이미,  물리 단계의 TABLE까지 상세 수준이 상세화가 필요
     ex> 사원테이블에서 사원구분-> **sub-type**으로 (정규직, 비정규직, 임시직) **상세화**
     ex> 고객테이블에서 개인/법인 구분을 -> **sub-type**으로 (개인, 법인) **상세화**
   - **논리 모델 -> 물리 모델**은  **분해(X) 변환**만! ( 이미 논리에서 상세화 끝)

3. **논리적 표현 원칙** : **논리** 데이터 모델링을 **거쳐서** **Entity로 추상화**를 한 다음에, 물리 단계로
   - 비즈니스 반영
   - 논리 모델은 독립적
   - 사용자가 원하는 것에 근거를 두어야함
   - 논리적 설계와 물리적 설계를 구별해야한다( 물리로 바로 가지 말아야 함)





## 제 2절 데이터 모델링 기법 이해

### 데이터 모델 목적

- DB설계에 대한 **계획 또는 청사진**
- **설계자, 개발자, 사용자** 등 관련자들이 **데이터 구조에 대한 형상을 이해,**  **원활한 의사소통**을 할 수 있다 (커뮤니케이션의 원칙)
- 서로 다르게 인식하고 있는 **뷰들을 하나로 통합**할 수 있는 **단일화된 설계안** 만듦
- **요구사항 정의**



### 개체-관계 모델 기법( Entity - Relationship Modeling)

- 피터 첸에 의해 1976년 최초 제안
- 개체-관계 모델은 표준 데이터 모델로 부상
- 개념/논리 데이터 모델링에서 가장 일반적으로 사용
- **서브타입이 추가되**면서 확장된 개체-관계 모델(Extended ERD)가 만들어 졌음
  - 요즘 ERD는 모두 E-ERD



 ERD Model을 사용하는 목적

- 관리자, 사용자, 개발자들의 뷰를 하나로 통합할 수 있는 단일화된 설계안 작성

- 요구사항을 정의

  

### 개체-관계 모델 구성요소

- 엔터티(Entity)  : TABEL과 대응

  - `Key Entity` , `Main Entity` : 핵심엔터티 in 개념 데이터모델 / `Action Entity` in 논리 데이터 모델에서 분해되는 것
  - key : 부모가 없는 신 같은 엔터티
  - action : 개념에서는 도출안하며, 논리에서 하나씩 분해되는 엔터티

- 속성(Attibute) :  Column과 대응

- **식별자(Identifier) : Primary key**

- 관계(Relationship)

- **존재 종속 : 부모-자식 관계** **(- 누가 무엇을 해서,   태어나게 하면 -)**
  ex> 고객 / 상품 / 카드 entity가 있다면, < 누가? 무엇을? 어떻게? > 의 관계를 보자.
          **`고객`**이 **`상품`**을 가입해서 --->  **`카드`**가 **태어난다.**
          고객, 상품 : 부모 ---> 카드 : 자식의 **존재 종속**
  ex> 사원 / 부서 entity가 있다면,
          사원이 ??해서 부서를 **태어나게 한다? (X)**
          부서가 ??해서 사원을 **태어나게 한다? (X)** => **부모자식(X), 존재종속(X)**
          사원보다는 **부서가 먼저 생긴다. [부서]---**ㅡ[사원] 
           한 사원이 여러부서?(X) **한 부서에 여러 사원(O). [부서]---ㅡ<[사원]**

  (- 부모-자식의 존재종속이 아니라면,  **선/후와 1:N관계를 생각**해보자. -)

  ex> 사원 entity에서 `sub-type`인 사원구분  : 정직원 or 임시직 -->      

- **서브 타입 : 베타적(Exclusive)** 또는 **포괄적(Inclusive)** 일 수 있다.





## 제 3절 데이터 모델링 표기법 이해

표기법의 종류

1. 바커 표기법(Baker Notation)
   - Richard Barker 등 여러명이 개발
   - 이후 리차드 바커에 의해 지속적 업그레이드
   - 오라클 Case Method로 채택
2. I/E 표기법(Information Engineering Notation)
   - Clive Finkelstein과 James Martin이 공동저술
   - James Martin에 의해 체계 정리되면서 본격 활용
   - 까마귀 발 모델(Crow's Foot Model)이라고도 불림



### 바커 표기법

![](http://cfile21.uf.tistory.com/image/990889405D1DE6BB3280C4)

1. **점선데이터가 먼저** 생긴다. (부서 -> 사원 순으로 생긴다.)

   - 먼저 생긴 점선 : **부서에** 사원이 있을 수도 있고 없을 수도 있다

   - 점선(optional) vs 실선(mandatory)
   - 만약, 신입사원으로서, 부서 발령이 아직 안났다면, 신입--- ---부서의 둘다 optional
      : 신입사원은 부서가 있을 수도 없을 수도 있다.

2.  부서의 **#부서코드** --> 사원의 ***부서코드(일반속성)**으로 : `비식별자관계(─)` 

   - 부서의 #부서코드 --> 사원의 #부서코드(식별자)로 간다면 `식별자관계(┼)`
   - my) 만약 관계의 끝에 `식별자관계`표기라면? # -> `#` (주식별자)으로 간다
   - my) 만약 관계의 끝에 `비식별자관계`표기라면? # -> `*` (일반속성)로 간다

3.  재귀관계 : #부서코드를 다시 받는다.(부모에서 X)

4.  1:N  vs  1:1관계 :  한명의 사원이 여러 부양가족을 ?( O )  < (1:M)
                                   한명의 직원이 여러 부서를? (X) - (1:1)





![](http://cfile24.uf.tistory.com/image/996EA8375D1DE6C422AC79)

바커표기법의 `sub-type`은 마지막 요소들이 속성이 되며, 실제 데이터 TABLE에 다 표기 된다.

`sub-type`을 정보공학적으로 표현하면, **베타적**은 **X**를 , **포괄적**은 **빈칸**을 가지고 있다.

![](http://cfile5.uf.tistory.com/image/994009365D1DE6D52CB8AD)



### ※ 서브타입 관련 문구

- 제2절 데이터 모델링 기법 이해 - 사. 서브타입 : 
  **서브타입은` 베타적` 또는 `포괄적` 일 수 있다.**
  - **베타적** : 서브타입 하위 4개 중 **1개만 선택 가능**
  - **포괄적** : 서브타입 하위 4개 중 **2개 이상 가능**

- 제3절 데이터 모델링 표기법 이해 - 1. 바커 표기법 - 마. 서브타입 : 
  **서브타입은 서브타입의 중복을 허락하지 않는 `상호 배타적`이다.**
  - **바커표기법에서만 상호베타적!으로 암기 **/ `일반적으로는 베타적or포괄적!`

- 제3절 데이터 모델링 표기법 이해 - 2. I/E 표기법 - 마. 서브타입
  **서브타입은 `배타적` 또는 `포괄적`일 수 있다.**



# 2장 개념 데이터 모델링

**순서** : 주제영역 정의 -> 주제영역내에 핵심 엔터티 도출 -> 그들간의 관계를 정의

- **주제영역 도출**(부서나누기)
- 후보 엔터티 선정
- 수집된 엔터티 분류
- **핵심 엔터티 정의**
- **핵심 엔터티 관계 설정**



## 제 1절 개념 데이터 모델 이해

### 개념 데이터 모델 정의

- 주요 핵심엔터티(key, main)들로 구성
- **`핵심 엔터티`**란 **행위의 주체나 목적물이 되는 개체 집합** cf)신용카드 : 개체집합 / 사원 : 행위집합
  - **Key** Entity : 사원, 고객, 상품 같이  **행위의 `주체` or `목적물`**이 되는 것 / 신과 같아서 부모가 없다.
    ex> 사원이 ~ , 고객이 ~,  A가 상품을 ~ 
  - **Main** Entity : 행위의 **`주체`** or **`목적물`** or **`언제`**했는지 에 걸리는 entity
    ex> **`신용카드`** : **고객**이 / **상품**을 가입해서 / **신용카드**가 **태어났다.**
           -> **부모-자식관계 ( 존재 종속 )**을 해석하는 것임
           **`신용카드`** : **고객**이 **신용카드**를 ?? 
           -> 주체나 **목적물**이 된다.
  - **Action** Entity : 행위의 주체, 목적물, 언제에 **`뭐를 했는지`** /  A가 B를 **C한다**.
- 부모가 존재하지 않는 창조된 집합(신) -> Key entity
- 다른 집합의 존재 유무에 상관없이 독립적으로 탄생
- 핵심엔터티는 대체적으로 여러가지 하위의 행위 엔터티를 탄생시킨다.

![](http://cfile7.uf.tistory.com/image/99F6F73B5D1DF54E1B880D)

- 고객, 상품, 가맹점 Entity는 부모가 없는 Key엔터티다 ex> 고객이 상품을
- 카드는 대표적인 Main엔터티다. ex> 고객이 카드를 ~



### 개념 데이터 모델 의의

- 주요 엔터티로 한정 지을 뿐, 논리 모델링과 똑같다
- 개념 모델링으로 핵심 엔터티들은 관계만 가지도록 하며, 
  분해(쪼개)지는 것은 이후의 논리 모델링에서다.
- 개념 데이터 모델링도 상세화가 진행될 수 있다.  
  = **개념 데이터 모델링에서는 `sub-type`으로 상세화** 한다.
- 상세화 되더라도 전체적인 골격의 개념적 모델을 벗어나진 않는다.



### 데이터 아키텍처 프레임워크 상에서 개념 데이터 모델

- 개괄 데이터 모델 : 주제영역(부서나누기)보다 상위
- 개념 데이터 모델 : 주제영역 하위(내부)



## 제 2절 주제영역 정의



### 주제영역 개념\*\*\*(-원기,방,목장,명)

- 기업 데이터의 **최상위 집합( 인사, 생산, 자재, 판매  등) --> 부서라고 생각하자!**
- 주제영역 내부(부서별로 서로) 데이터의 관계는 밀접 <-> 다른 주제영역(다른 부서)와는 상호작용 최소화
  -> **높은 응집도 / 낮은 결합도**
- 데이터는 관계구조로 표현
- **`관계구조`**는 관계가 복수 개로 연결되어 **하향식 분석(주제영역->key->main순)이 용이하지 않음**
- **`계획 수립단계`**시에만 **하향식 분석**을 원칙으로 함
- **`검증`**시에는 **상향식 분석**을 사용
- **`주제영역`**은 **하향식 분석시 유리** 
  (**주제영역을 계층적으로 분해한 -> 하위주제영역 -> Entity**)
  my) 계획수립단계, 주제영역 정의시 하향식  /  관계구조, 검증시 상향식



cf) **`아크`** = **관계가 베타적(택1)**인 것 ->  **`통합`**한다
ex> 개인entity / 법인entity --> 계좌entity 관계에서, 개인과 법인은 베타적이다.
       **베타적일때는 고객Entity로 통합**해버린다.

![](http://cfile5.uf.tistory.com/image/99CB5C495D1DF975460B04)



### 주제영역 분류 원칙 및 기준

가. 주제영역 분류 원칙

- 중복 최소화
- 확장성 보장
- 관련성 및 편의성 확보
  

나. 주제영역 분류 기준

1. **데이터 관점**에서 분류
   - 주체, 목적물(key) 및 행위(action) 등 **데이터를 생성시키고 사용하는 유형에 근거**
   - **전사적인 관점**에서 데이터 유사성 고려
   - 시스템과 어플리케이션이 다르더라도 **동일한 유형의 데이터를 유사한 방식으로 사용한다면 통합된 관점에서 데이터 관리**
2. 추가에 대한 **유연성 보장**
3. 주제영역간 **균형유지**
   

다. 주제영역 **명명(** 명명 = 이름 = 커뮤니케이션의 원칙 -> ERD그려놓고 이야기)

1. 실업무의 **보편적 용어**
2. **단수**형 명사
3. **데이터 그룹(주제영역)을 의미**하는 용어



### 주제영역 활용

가. 목적

- 계층적 구조 파악에 도움
- 최상위 단위 역할을 하므로 품질 확보에 기여
- 데이터 구성에 대한 청사진
- 데이터 구성 및 통방에 대한 방향 제시(선언적 성격)
- 효율적 데이터 관리 기준 제공



나. 장점

- 품질보증
- 프로젝트 관리 용이
- 개발 조정 용이
- 리포지터리 관리 용이
- 상세한 전개 혹은 축약 가능
  **\*\*\* 주제영역은 `생산성`과는 무관하다!**

### 주제영역 도출

가. 데이터의 **명사형 도출**

나. 업무 **기능의 이름으로부터 도출**

다. **하향식** 접근 방법으로 도출

- 주제영역 -> 엔터티 타입으로 전개

라. **상향식** 접근 방법으로 도출

- 엔터티 타입을 그룹핑 -> 주제영역 도출

마. **분석단계**에서 도출

- 아키텍쳐 모델 정련과정에서 도출
- 데이터 모델 상세화 과정에서 도출





## 제 3절 후보 엔터티 선정

### 개념

- **후보의 자격여부만 판별**
- 실제 엔터티를 **확정하는 별도의 단계는 따로 있다.**



### 엔터티 후보 수집

- 기존 시스템 문서
- 현업 장표 / 보고서
- 현업 인터뷰
- 관련 전문 서적
- 데이터 흐름도(DFD)
- \***\*\*타 시스템 자료** - 또한 주제영역의 후보이다
- 현장조사



### 엔터티 후보 식별 (\*\*\*후보 엔터티 요건 3가지)

- 후보에 대한 **개념정립을 명확히** 한다.
  ex> 사원Entity의 후보를 만들 때,  정규직만 개념에 포함시킬 것인지 / 임시직, 협력사 다 포함 시킬 것인지 개념 정립
- **우리가 관리하고자 하는 것**인지 따져 본다.
- **가로와 세로를 가진 면적(집합)인지 확인**한다. 
  = 가로 : 속성2개이상 / 세로 레코드 2개 이상의 데이터 인지 확인



### 엔터티 후보 선정시 유의사항(\*\*\*)

(-깊, 모, 가, 동 / 예, 프, 단 -)

1. 너무 **깊**게 들어가지마라 (지금은 개념 데이터 모델링)
2. **모**호한 대상은 개념을 상식화하여 이해하라(회사에서만 쓰는 대상을 공공화?)
3. **가**능성이 있다면 바로 검토대상에 올려라
4. **동**의어처럼 보이더라도 함부러 버리지마라
5. **예**외 경우에 집착하지마라
6. **프**로세스에 연연해 하지마라
7. **단**어 하나하나에 집중해서 판단해라



### 수집된 엔터티 분류

**가. 우선 적용 대상** **분류 **( 개념단계이므로 key, main만 찾아서 분류)

1. **키** 엔터티 : 행위 **주체나 목적어**
   ex> 사원**이**, 부서**를,** 고객**이,** 상품**을**, 자재**를**

2. 메인 엔터티 : **키 엔터티보다 더 하위** 행위를 발생시키는 **주체나 목적어**

   **my) 부모를 가지는 주체나 목적어**
   ex> 보험계약**을** / 사고**가** / 예금원장**이** / 청구**를**

3. 액션 엔터티 : **주체나 목적어 이외의 나머지** 엔터티 전부 my) ~가 ~를 한 **내역**
   ex> 상태**이력** / 차량수리**내역** / 상세주문 **내역**


**나. 데이터 영역별 분류** -> **\*\*\*통합과 분할의 기초자료로 활용하기 위함**

1. 사람 : 사원, 가입자, 회원, 고객, 학생 교사
2. 물건 : 부품, 원재료, 연료, 저장품
3. 사건 : 계약, 수주, 주문, 발주, 재해
4. 장소  : 참고, 생산라인, 행적구역, 하천, 선거구



## 제 4절 핵심 엔터티 정의

### 핵심 엔터티 정의 요건(5) \*\*\*

1. **관리하고자 하는 것**인지 확인(후보2)
2. **가로와 세로의 면적**인지 확인(후보3)
3. **개체간 동질성**이 있는지 확인 -> 통합할 것임 ex> 학생-강사 --> 사람entity로 통합
4. 다른개체와 구분되는 **독립성**을 가지는지 확인  ex> 고객-사원 --> 하는 일이 다르므로 통합X
5. **순수한 개체(순수성)**인지 **행위집합**은 아닌지 확인
   - 순수성이 아닌 것 : 납입(행위집합) + 자(개체집합)이 합쳐진 것
     ex> 납입+자 / 불량거래+자 / 거래+자 ---> 이렇게 **개체+행위가 합쳐진 entity**일 경우
            **사람 1명을 찾을 때**,  납입+자 에서 검색1번 / 불량거래+자에서 검색2 / 거래+자에서 검색3 ---> **~자 가 붙은 entity 모두 총 3번을 검색해야한다**.
   - 행위 집합은 Action Entity로서, 핵심엔터티(key, main)에 속하지 않으므로 배제한다

> 후보엔터티의 요건 3가지 \*\*\*
>
> 1. 개념 정의가 명확한지
> 2. 관리하고자 하는 것인지
> 3. 가로와 세로의 면적인지 



### 의미상 주어 정의

가. **`본질 식별자`** 정의의 의의 (물리 모델 - PK)

- 집합의 의미가 모호한 상태에서는 판단 진행이 불가능하다
- **집합의 의미를 명확하게 해준다.**



**cf) 식별자의 종류**

1. **`본질 식별자`** : **부모entity(누가,무엇을해서--> 해당 entity가 태어남)**에서 그**대로 물려받은 식별자** / **`uid_bar`** = **`식별자관계(┼)`**를 만들어준다
   <-> **`인조 식별자`** : 부모로부터 물려받다가 **너무 깊어질 것 같아서, 중간에 끊어 새로 만든 식별자** or **Key Entity의 식별자** 
    \*인조 식별자를 사용한 entity는 Join을 통하여 부모를 찾아가기힘들다.
2. **후보 식별자** :  사원Entity의 주민등록번호 같은 ...
   <-> 대체 식별자
3. **실질 식별자 : 실제로 # 표시가 붙은 식별자들**



cf) **식별자관점에서 그려보기*****

- **Main** Entity(**부모가 있는 주체,목적물**)은  **부모의 식별자/uid_bar/본질식별자를 다 사용**해야한다.

- **Key** Entity는 부모가 없어서 받을 식별자가 없으니 **인조식별자**다

- 부모가 있는 **Main(부모있는 주체,목적물) / Action(나머지)** Entity는 **부모를 가지므로 본질식별자를 무조건 써야**한다.
  그러나 **Main** Entity의 경우, 타고내려다가다가 **너무 많은 본질식별자를 가지게 될 때**,

  join시 필요한 식별자가 너무 많아지므로, **`인조식별자`를 만들고 부모의 본직식별자를 일반속성으로 사용**할 수 있다. 이 때는**, `uid_bar/식별자관계(┼)가 끊어진다`**면서 
  그러나 join을 통해 부모를 찾아가는 것은 어려워진다.

  

![](http://cfile28.uf.tistory.com/image/99C040375D1E0B982641DC)

고객과 상품을 통해 카드 entity가 태어났다. **카드**는 **부모를 가진 주체/목적물인 Main** Entity이다.  그러므로 **2 부모의 식별자를 모두 사용해서 본질식별자가 2개**가 된다.



![](http://cfile25.uf.tistory.com/image/997295425D1E0D7A2F21AC)

A, B의 자식 --> C 의 자식 --> E 에서
C는 부모 A, B의 식별자를 모두 사용해야하므로 본질식별자(uid_bar/식별자관계)를 2개 가지며, 자신의 식별자 또한 가지고 있다.

E는 부모인 C에 있는 식별자 #AA, #BB, #CC를 모두 본질식별자로 가져야하므로 
자신(#EE)의 식별자가 4개가 된다.  
이 때, **uid_bar/식별자관계를 끊고 = 부모의 식별자를 일반속성으로 두어서 인조식별자(#EE)만 사용**할 수 있다.





**나. 본질식별자 정의의 예시**

- 신용카드 엔터티(자식)의 상품과 고객 속성은 부모에게서 상속받은 릴레이션쉽
- 본질식별자로 상속관계를 규명해 올라갔 을 때 최상위는 키 엔터티(부모가 없는 신)
  - 의미상의 **주어 = 부모** ex> 고객**이** 상품**을** 가입하여  **신용카드가 탄생했다**.
  - **`의미상의 주어`를 이용해서 부모를 찾아가자!!!*****
- **주의할 점** : 1:M관계에서  1쪽이 항상 본질식별자가 되는 것은 아니다.
  - **`관계종속`(참조) vs `존재종속`(부모-자식) 감별하는 방법*****
    부서---ㅡ사원 : 부서가 **없어지면** 사원이 **없어진다**?  (X) => 관계종속
    사원---ㅡ부양가족 : 사원이 **없어지면** 부양가족이 **없어진다?** (O) => **존재종속 (부모-자식)** => **본질식별자 / uid_bar/ 식별자관계**
    ![](http://cfile23.uf.tistory.com/image/99B8D53F5D1E11A705E7AF)

- 본질식별자란? 없다면 자신이 절대로 태어날 수 없을 때만 해당(부모가 있다)



### 코드성 키 엔터티 모델링***(요건 3가지)

**분류코드 같은 속성**을 **`코드성 키 엔터티`**로서 **별도의 엔터티**로 만들어야할까?
단순히 분류만을 위해서라면, 딱히 따로 엔터티로 뺄 필요가 없으나..

1. **자식 엔터티**를 가지는 경우, 따로 뺀다 
   ex> 설비TYPE (속성) - 펌프/배관/발전기/압축기/발전기  중  하나를 적어서 분류한다.
         그러나 **설비**가 **공정(자식)**을 **태어나게 한다 **/ 설비가 **없어지면**, 공정도 **없어진다**.
         => **부모가 없는 코드성 키 엔터티로 빼내자!**
2. 자신만의 **다양한 속성**을 가지는 경우,
   ex> 코드 / 코드명 / 코드자격 / 등등 **뒤에 많이 달고 있다면, 따로 엔터티로 빼내자!**
3. **여러 엔터티와 관계**를 가지는 경우, (자식을 가지는 경우와 비슷)
   ![](http://cfile9.uf.tistory.com/image/99996F4B5D1E13CF082A03)



### 집합(엔터티의 개체or행위)의 순수성

가. 순수성의 의미

- 개체집합(주체, 목적물)이거나 행위집합(목적물)이거나 둘 중 1개
  - 개체 집합 : 고객, 상품 등
  - 행위 집합 : 입금, 계약
- (순수성 위배) 충돌의 경우 : 
  납입 + 자, 입금 + 자 ==> 행위 + 개체 -> 개체 조회시 3 entity 모두 검색 ===> 사람으로 통합

나. 집합 순수성의 예

- 납입 + 자 : 관계속성 + 고객entity 로 나누어봐야함

**다. 집합 순수성 예외사항*****(암기)

- 릴레이션쉽을 엔터티화 한 것 ex> 피보험+자

- 일부 집합 정의 ex> 금융+기관

- 배타적관계 (아크)를 없애기 위해 통합해놓은것 ex> 고객,공사현장,물류센터 -(통합)-> 배송처

  ![](http://cfile5.uf.tistory.com/image/99E4003D5D1E165C2274C0)
  고객Entity (부모)  ---- 계약Entity (자식) 사이에서
  **[부모]의 속성**인 **고객 TYPE에 따라 -> [자식]의 속성을 모두 `병렬식`으로 나열**해놓았다.***
  이럴 때는, **`부모TYPE --> 자식이 병렬식 속성들`의 **관계**를 **`중간에 하나의 엔터티로 통합`하여 `직렬식`**으로 만들 수 있다. 
  [부모]의 고객TYPE --->  **[보험계약관계자]의 계약자 구분코드** <--- [계약]의 계약자 고객번호
  ==> 관계를 엔터티화 한 예제이다. 
  ex> 피보험+**자** = **부모의 고객** -- [피보험자] -- 자식의 보험종류

### 집합의 동질성(=통합)

- 정직원만? 협력업체 직원? 아르바이트?  ==> 사원으로 통합
- 개인고객과 법인고객 ==> 고객으로 통합



### 엔터티의 명칭

적절한 엔터티 명칭

- 함축시킨 의미
- 오해를 최소화



### 서브타입(분류 속성)

**가. 서브타입 지정시 고려사항**

- 교집합 허용 불가 ex> [배우 여부] or [가수 여부] --> 배우이면서 가수인 사람 존재
- 합이 전체 집합 ( 배반인 것만 분류속성=서브타입으로 )
- **서브타입 표현의 기준**
  - 개별 **속성**을 가지는 경우
    **subtype으로 묶지 않았을 때는 optional / 묶으면 필수적(mandatory)가 되는 경우?** ***?
  - 개별 **관계**를 가지는 경우
    다른 엔터티와 관계를 가지는 경우
  - **가독성 증진**을 위할 경우
    ![](http://cfile28.uf.tistory.com/image/99D7D4455D1E1B2B0DC12D)

**나. 서브타입 도출**

1. **분류속성** : 분류속성에 따라서 **엔터티의 정보가 차별화** 되는 경우
2. **`다수`의 선택적 속성**( **소수의 선택적 속성은 오답** ***) : **서브타입 도출시 **필수속성으로 변하는 경우****
3. **선택적 관계가 존재**하는 경우 : 선택적 관계가 -> **필수적 관계로 변하는 경우**
4. 도출 절차
   - 분류 속성 확인 --> 차별화 되는지 확인
   - 분류 속성 값에 의해 분류되는 서브타입 파악
   - 분류 속성에 따라 필수/선택적 분할 정의
   - 서브타입별 속성 할당
   - 슈퍼타입의 관계를 해당 서브타입에 정의
     

**다. 서브타입의 활용**

1. 업무규칙을 명확히 표현하여 이해를 도움
   - 가독성 향상
   - 속성의 선택성이 제거됨 (필수적으로 변해서)
   - 관계의 선택성이 제거됨( 필수적으로 변해서)
2. 서브타입의 표현으로 업무규칙의 **`명확성`과 `복잡성`**은 **트레이드 오프관계** -> **조화**가 필요





### 엔터티 통합과 분할

통합할수록 유연성은 증가 / 동질성은 감소

현업) 키 엔터티는 통합할려고 함. 메인 엔터티는 통합안하려고 한다.

- **집합 동질성 확대를 위한 통합 사례(\*\*\* 암기)**
  **보험**회사의 **대리점** : 조직이 아니므로 **사원**에 통합시킴
  **통신**회사의 **대리점** : 조직이므로 **조직**에 통합시킴

- **유연성 향상을 위한 통합**
  집합의 확장(통합)은 유연성과 단순성 증가 but 지나친 확장은 의미를 희석한다
  *\*\* **상위 엔터티(key entity) 일수록 통합의 효과가 좋다** -> 현업에서는 key는 통합 main은 통합x 할려고함
   -> 상위 엔터티가 분할되어 있다면, join or 의미상의 주어로 부모를 찾아가기 힘듬.

![](http://cfile21.uf.tistory.com/image/998414485D1E1F9103C196)

