## 제 5절 관계 정의

### 관계란?

엔터티와 엔터티 사이의 관계



### 관계 이해

1. **관계도 집합**이다. 111
   하나의 인스턴스(row) ---ㅡ<여러개의 인스턴스(rows)를 가진다
**관계도 속성**이다. 111(부모의 식별자가 자식으로 내려오니까)
   
2. **직접 관계**를 관계라 한다.1]

3. 두 엔터티 간에는 **하나 이상이 관계**가 존재할 수 있다.
   ex> [고객]   ---ㅡ<  [보험계약]의 관계 :  많은 관계가 있다.
     #고객 (번호) 1명당  ㅡ계약자,
     ~~#고객 번호 1개당~~    └ 피보험자,
     ~~#고객 번호 1개당~~    └ 종피보험자1
     ~~#고객 번호 1개당~~    └ 종피보험자2 같이 여러 관계가 나올 수 있다.

    **관계 1개당 기본키(\#) --- ㅡ외래키 1개(\*)**이므로
   [보험계약]에서는 관계만큼 **외래키 \* 계약자(피보험자, 종피보험자1, ,,,) 고객번호**를 가진다.

   ex> [사원]  >ㅡ--- [부서]의 관계
     #사원 번호        #부서번호
     \* 현소속 부서    **? 부서장 사원번호**

      - 한 [부서]---ㅡ< 여러명의 [사원]을 가지는 관계이다.

      - 근데, 부서마다 부서장 (사원번호)가 넣어줘야한다고 한다.
        그렇게 되면, [사원] ---ㅡ[부서]의 관계일 수 있을 것이다.
        그러나, [부서]---ㅡ[사원]  / [사원] ---ㅡ[부서]의 **마주보는 관계라면, 둘중에 한 관계는 끝이 optional**이어야 모순이 발생하지 않는다. **중요도에 따라서 하나의 관계를 필수**로 지정한다. 
        my) 원래는 one #(PK)를 끌어다가 ---ㅡ< many의\*(FK)로 잡아준다.
                **one=**[고객]의 **PK(#)**고객번호 **---끌어다가**
                 **ㅡ<many**=[보험계약]의  **FK(*)**계약 고객번호**로 잡아주는 경우가 많다**.

        **ERD 참고사항 2 )111**

        1. 고객이 계약을 **??태어나게?? (X)** ---> **참조(선후)**관계, **부모자식관계(X)**
                  고객---ㅡ계약 결정
                   * 참조관계에서 **누가(선, 선택) ---** **무엇을(후,필수)** **성립시** **주어** => -**---점선시작**
                     - 각각의 입장에서 `누가 무엇을`의 성립여부 -> `주어가 선택---`의 관계를 따져본다
                        * 만일, 부모자식관계라면? **앞쪽 실선 ㅡ**ㅡ
                     	* 앵간하면, **부모의 식별자(주어)를 그대로 가져와ㅡㅡ`┼`(uid_bar)가 달린 체로** 사용 : **# 본질식별자**
                     * 자식은 # 본질식별자 + # 자신만의 식별자
                     * 너무 많이 타고내려와 자식의 식별자가 너무 많을 때 : # 인공식별자
              
         2. **한** 고객이 **여러개의** 계약을 --->   **ㅡ< 결정**
 3. **one의 #(PK)**를 끌어다가 ---ㅡ< **many**의 ***(FK)**로 **작명**해주기
        
        
     그러므로, [사원]>---ㅡ[부서] + [사원]--- **---**[부서]의 **o부서장번호**로 표기해야한다.
        cf) 관계의 점선 실선
        
        1. **---**ㅡ: 앞쪽 점선은 시작& 선후관계
        2. **ㅡ**ㅡ: 앞쪽 실선은 시작& 부모자식관계
        3. ---**ㅡ**: 뒤쪽 실선은 \*필수 관계
     4. ---**---**: 뒤쪽 실선은 o선택 관계
           ![](http://cfile9.uf.tistory.com/image/9954EE425D2717C21C9F3D)
   
4. **외래키**로 정의한다.

   - 관계 하나당, 외래키(\*식별자)로 들어간다.

5. 관계의 **관점**

   1. 항상 2 엔터티 간에 존재한다.(2개의 entity 각각 관점을 살핀다.)
   2. 항상 2개의 관점을 가진다.
   3. 데이터 양방향 업무 규칙을 표현
   4. 정보로서의 활용가치 상승(RDB는 관계로서 정보를 얻음. join해야됨!)
   5. 외래키로 구현되어 **참조 무결성**으로 데이터 정합성을 유지 
      - 물리 모델링에서는 참조 무결성을 정의한다.
      - Referencial Integrity(참조 무결성) **R-I관계(PK-FK)**는??
        -> **핵심entity(key간, main entity간)간에는 연결하는 것**이 좋다!
        -> **재귀관계, BOM관계**(#상위부서)는 반드시 RI관계를 엮는다.
        -> Constraint , Trigger or 어플리케이션에서 만들수 있다.



### 관계 표현

1. **관계 형태 : 자식쪽에 자식의 속성명을 적어주는 것이 80~90%는 맞다**.
   80%는 **[자식] >ㅡ---[부모]를 바라보는 관계**를 **`자식 엔터티 옆`에 적어준다**.
   ex> **[고객]**  #고객번호 ---ㅡ*`계약자+ 고객번호`(**자식역할 + 부모의 속성명칭**)<  **[보험계약]** : 
2. 선택사양
   * 일반적인 형태
     * one : 선택 --- ㅡ< many : 필수
     * 가장 많이 나타날 뿐, 바람직한 형태X
   * 바람직한 형태
     * **자식쪽**에 가능한 **직선관계**를 가지도록 노력 
     * 그렇지 않으면, 정합성의 문제점
3. 관계명
   1. 2개의 관계 멤버십에 각각 부여 (각자 상대방 입장에서)
   2. 현업) 속성명칭, 시험)동사형으로 표현
      1. 연관성
      2. 현재시제
      3. 유일성은 보장X
      4. 능동/수동 형은 가능한 배제
   3. 업무적 의미 없거나, 애매모호한 용어는 X
      1. 고객관리(X) -> 고객 entity
      2. 고객정보관리(X) -> 고객
         - 관리, 정보관리라는 말은 이미 entity에 내포된 말이다.



### 관계 정의 방법



### 관계형태

#### 1:1 관계

현실에서는 거의 나타나지 않는다. 만약, 나타났다면 통합해야할 관계이다.

가장 많이 하는 실수는 아래와 같은 경우다. 

* **1: 1관계** = 부모와 자식간의 **식별자가 똑같다**.

* **자식의 식별자를 더 도출**해야하거나,  **두 엔터티를 통합해야한다**.

![](http://cfile25.uf.tistory.com/image/996525345D27284C147D02)

또한, **1:1관계는 엔터티 수직분할**시 많이 나타난다.

* 속성(columns) 200개가 넘어가서 -> DB의 I/O의 단위는 블록(8k)단위 인데, 블록하나에 다 못들어가서 쪼갠 것 in 물리 데이터모델링



##### 1:1인데, 필수:필수  (ㅡㅡ)

완전 동치 entity, 논리모델링에서 잘못 나눠놓은 것. 똑같은 entity다



##### 1:1인데,  필수:선택(ㅡ---)

1:M ---ㅡ< 관계에서도 1이 PK ---ㅡ< Many의 **필수(ㅡ)쪽**에  **FK(외래키)**로 두었다. ( Many에서 FK로 one을 조회)

1:1 ---ㅡ 관계에서도,  **필수쪽에 외래키**를 둔다.



#### 1:M 관계

##### 1:M인데, 선택:필수(---ㅡ<)

가장 흔한 형태. 1쪽이 optional (시작, 주어!)
ex>[부서]---ㅡ<[사원]   (부서가 사원을 받는다. 사원이 부서에 등록.. 부서를 X)

* 사원 **ㅡ**--- : 사원은 반드시 부서를 가진다.
* 부서 **---**ㅡ : 부서는 사원을 가질수도 가지지않을 수도 있다.

##### 1:M인데, 필수:필수(ㅡㅡ<)

현실세계에서는 거의 나타나진 않는다. M:M해소하다가 새롭게 나타난 M:M해소시 등장

ex>[주문] ㅡㅡ<[주문상품],  [대여]ㅡㅡ<[대여도서]



##### 1:M인데, 선택:선택(--- ---<)

의외로 흔한 형태, 1쪽이 option(시작, 주어)인데, M쪽도 optional(시작, 주어가 됨)

ex> [사원] >--- ---[부서] 

* 부서는 여러명의 사원을 받을 수 있다.
* 그러나 처음 입사시, 사원이 소속 부서에 속하지 않을 때가 있다.

그러나, optional이 많아 질수록 모델의 모호성이 증가하므로,
**M쪽에서 optional을 없애려고 노력**해야한다.

* 사원 entity에, *인사부 발령번호를 추가해서, 실선으로 만들어버린다. 



##### 1:M인데, 필수:선택(ㅡ ---<)

**`여러번`의 `선 납품`이후에  `한번`의 `후 청구`**가 일어나는 경우, 
**여러번의 선 외상 이후에   후 집계, 청구** 같은 경우가 **M쪽이 선택, 1쪽이 필수**

ex> [카드사용] >--- ㅡ[청구]

* **[카드사용]**이 **먼저(---)** 생기고  **[청구]**가 **뒤(ㅡ)**에 생긴다.(먼저쓰고 나서 생김)

* 그러나, 한 청구에 여러 카드사용이 있을 수 있는데,  한번의 카드사용에 여러번 청구가 생길 순 없다.



#### M:M 관계 해소

M:M관계는 거의 **90%가 양쪽다 점선(선택)**이다. >--- ---<

* 고객**이 여러개의** 상품**을** 구매 O : [고객] **---** ???
* 상품**이** **여러명의** 고객**에게** 판매 O : [상품] **---** ???

![](http://cfile26.uf.tistory.com/image/995184425D2732A31C1454)

현실세계에서 의외로 빈번(이 아니라 모든 관계가 M:M 선택:선택인데, 1:M으로 풀어나가는 것)

* 모델의 가장 상위가 [고객], [상품]의 key entity들이며, M:M관계를 가지고 있다.
  이것들을 1:M으로 분해 해나가면서, 모든 것이 성립하게 된다.
  ex> [고객, 누가]이 [상품, 무엇]을 [카드, 어떻게]로 구매한다.  또 [카드]에서 [카드사용]이 나온다. ...

M:M은 덜 풀려진 관계이므로, **M:M관계가 해소될 때까지 분해**한다.

* 항상1:M관계로 풀리는 것은 아니며, 또다른 M:M관계가 나타날 수 있다.
  * 최상위 엔터티 2개는 90%는 양쪽 점선의 M:M이다. [고객]>--- ---<[상품]
  * 이 M:M관계를 풀려고 자식인 [주문]이 태어난다 (고객이 상품을 구매시, 주문이 태어남)
  * 그러나 M:M관계를 풀려고 했더니 새로운 M:M관계가 나타나려고 한다.(목적물과 자식)
    * [고객] ---ㅡ< [주문] >ㅡ----**`<`**[상품] : 한 주문에 여러 상품들이 들어간다.
    * [고객] ---ㅡ< [대여] >ㅡ----**`<`**[도서] : 한 대여에 여러 도서들이 들어간다.
  * 목적물(부모)쪽의 M(---<)관계를 해소하려면, [목적물+자식] 조합의 새로운 엔터티를 만들어야한다. 이 때, 관계는 **필수:필수의 관계**다
    **( M:M해소하려 자식생성-> 목적물-자식간의 M:M -> 목적물+자식조합의 엔터티는 자식과 필수:필수(ㅡㅡ)관계!!! )**
    * [상품]`>`---ㅡ< [주문] :  [상품]---ㅡ<[주문] `ㅡㅡ<`[주문상품]
    * [도서]`>`---ㅡ< [대여] :  [도서]---ㅡ<[대여] `ㅡㅡ<`[대여도서]![](http://cfile1.uf.tistory.com/image/99BE09435D2739AF1E001C)



Q. M:M관계가 나오면, 보는 즉시 1:M관계가 될때까지 분해한다? (X) 111
=> 즉시라는 말 틀렸다. 액션 엔터티와 M:M관계라도, 액션엔터티111는 개념단계에서 건들지 않는다.
     개념 데이터 모델링에서는, key, main(핵심)엔터티만 분해한다.

Q. entity 상세화 단계에서, M:M 관계가 나타났을 때, 1:M관계가 될때까지 분해한다 (O)
=> 속,엔,이 => 논리단계이므로, 액션엔터티도 분해시킬 수 있다....

Q. M:M관계를 풀었떠니 항상 1:M 관계가 나온다?(X) 111
=> 새로운 M:M관계가 나와111, 목적물+자식조합의 엔터티를 필수필수로 만들었다.
=> 대표적인 예가, [주문]-[주문상품]의 필수필수관계111
=> 최종 논리모델을 끝낸 상태에서는 M:M관계가 나타나선 안된다111



#### 현실세계에서의 관계 3가지111

1. **M:M 관계**111에서 시작 : 최상위 엔터티 2개, 이것을 분해해간다. 

   ex> [고객]>--- ---<[상품], [고객]>--- ---<[도서]

2. **1:M 관계**111

   * **1쪽이 선택111 : 필수** 관계 : 1쪽이 optional(선택, 선or주어or뒤에께 없어도 됨 ) : M쪽이 필수(후or목적어or뒤에께 필수) 가 많다.
     ex> [부서]---ㅡ<[사원] : 부서가 사원을 가지지 않을 수 있다.
     ex> [고객]--- ㅡ< [상품] : 고객이 상품을 구매하지 않을 수 있다.

   * 필수:필수 관계 111
     [주문]ㅡㅡ<[주문상품]111 : 주문은 반드시 주문상품을 가진다. / 주문상품도 주문을 반드시

     [대여]ㅡㅡ<[대여도서] : 대여는 반드시 대여도서를 가진다. / 대여도서도 대여를 반드시

   * **둘다 선택111 : 선택** 관계 : 둘다 선, 주어가 될 수 있는 관계 , **M측을 필수로 만들자111**
     ex> [부서]--- ---< [사원] : 부서가 없는 ---<사원이 있을 수 있었다.
   => 사원이 발령나면, 무조건 인사부서로 발령내는 방법으로 M(사원)쪽을 필수로 만들 수 있다.111
     
   * 1측이 필수 : M측이 선택 관계111 : 
     먼저 여러개의 카드사용or납품 후   -->  나중에 한번에  청구, 집계111

3. 1:1관계 : 거의 나타나지 않는데, 

   * 필수:필수는 => 동치이다. 111
   * 선택:필수라면 => 필수쪽이 외래키를 가진다.111(원래는 1:M에서 M쪽이 외래키)



#### 다중관계 처리

병렬식 VS 직렬식 : 개발자(병렬식)과 모델러(직렬식)가 가장 많이 싸우는 이유

##### **병렬식**111

화면에 같은 **같은 위상의 속성들이 병렬적으로 나열**, 현업에서 많다.

1. where조건절에 병렬속성으로 조회되지 않는다면 병렬식 가능
   => **where 조회조건에 들어간다면? 직렬식111**
2. 병렬속성들이 서로 쌍을 이루어 존재하지 않는 경우 병렬식 가능
   ex> 계약자 / 계약자 가입일자 / 피보험자 / 피보험자 가입일자
   **=> 쌍(pair관계)로 간다면 -> 직렬식**111
3. 속성이 추가될 가능성이 없다면 병렬식 가능
   => **속성이 더 추가된다면? -> 직렬식111**

![](http://cfile30.uf.tistory.com/image/996C1C385D287FB12C9226)



##### 직렬식

병렬식의 **병렬속성들은 제1정규형 위배**이며, 속성추가에 대한 **유연성이 없다**.

1. **병렬속성**들을 **통합한 자식entity를** 만든다.

2. 자식entity이므로 **부모식별자를 가져온다.**

3. **자식(자신) 만의 식별자**로서, 
   1) 병렬속성들의 **명칭으로 구분**하는 **구분속성**

   2) 병렬속성 **구분** **코드속성**

4. **상세관리**를 위한 **부모식별자(#) 중 하나를 필수속성(*가입일자)로 가져오기**

![](http://cfile28.uf.tistory.com/image/99C0164E5D287FB603607E)

##### 병렬식vs직렬식 요약

* 병렬식

  * 장점 : 여러개 칼럼으로 나열, 테이블 추가 불필요
  * 단점 : 인덱스 수 증가, SQL복잡, 관계추가나 변형에 취약, 상세정보 관리 안됨

* 직렬식

  * 장점 : 관계들이 (자식entity로서) row형태로 나타난다(데이터 추가만 해주면 됨), 인덱스가 감소(where에 들어갈 칼럼이 적어짐), SQL단순, 관계에 대해 유연, 관계별로 상세정보관리가능(부모식별자를 하나 가지고 와서 필수로)
  * 단점 : 엔터티가 1개 추가된다는 점(자식entity)

  

##### 특수한 형태 관계

1. 순환 관계(Recursive Relationship) = **재귀 관계**111
   ex> **부서코드111, 조직코드**

   * 하나의 순환 엔터티는 각 엔터티의 모든 속성을 포함해야한다.
     -> 회사entity - 본부entity 2개 - 부서entity 4개 의 구조라고 가정하면,
         entity들 모두 속성 개수가 똑같아야 한다는 말
   * 각 계층에 있는 속성은 동일하게 하는 것이 가장 좋다. -> 같은 말
   * 순환 모델은 필수관계(직선ㅡ)로 취급될 수 없고, **재귀 관계는 반드시 <선택:선택>관계111**
     -> 부서코드, 조직코드 칼럼은 O 부서코드 처럼 선택으로
     => O상위 부서코드 를 넣어주면 해결된다.
   * 순환 모델은 조직의 변경에 쉽게 대응

   > 순환관계 SQL***
   >
   > SELECT -
   > FROM 조직
   > Start with 상위조직 is null
   >
   > Connect by 상위조직 = Prior조직(FROM에 읽어놓은 조직), 구조
   >
   >  
   >
   > *** is null은 인덱스로 쓰지 못하므로
   > 개선된 순환관계 SQL
   >
   > == 가장 상위조직(회사) 위의 Dummy조직을 만들어놓고111==
   >
   > SELECT - FROM 조직
   > Start with 상위조직 = 'Dummy'
   >
   > Connect by 상위조직  = Prior조직, 구조
   >
   > 
   >
   > cf) 인덱스로 쓰지 못하는 3가지
   >
   > 1. 좌변가공?
   > 2. null
   > 3. 묵시적 형변환

   
   
2. BOM 관계111 (Bill of Materials 관계) : **M:M recusive다111**
   상위조직코드에 한 데이터 값만 가지면 됬으나, 부모가 2개 이상이 되는 경우
   즉, 재귀관계가 M:M관계로 인해 교차엔터티가 1개 나온다.
   세상의 모든관계를 집어 넣을 수 있는 관계
   자세한 설명은 생략

   ex> [공정]에서 [조립]의 관계
   ex> 비행기바퀴를 만들려면, 오른쪽날개/왼쪽날개/꼬리날개 -> 상위부모가 3개![](http://cfile28.uf.tistory.com/image/9968A9335D2888AE0E2AD6)
   ![](http://cfile26.uf.tistory.com/image/998ADC3F5D2888B2309F16)
   ![](http://cfile4.uf.tistory.com/image/994151355D2888B6071F87)

   
   
3. **아크(Arc)관계111** 
   그림으로 이해하는 것이 좋다.

   - `sub-type` : (개인/법인고객)**구분속성**에 대해, 그냥 두면 잘 모를 것 같아서 **값을(1or2) 도식화** 한 것이다.

     ![](http://cfile25.uf.tistory.com/image/997CAC425D28923301F6E6)`arc 관계` : **외부의 여러entity에서 받아온 관계**가 **`서로 배타적인 관계`를 도식화**한 것
      ![](http://cfile25.uf.tistory.com/image/99179A395D28924916584D)


    

   1. **아크에서 관계는 보통 동일하다111**. (**필수 관계가 아니라 cardinality**111)
   2. **아크 관계는 항상 필수 or 항상 선택이다.111**
      
      - 배타관계를 받아오는 entity에서 2 中 택1의 속성이어도, 항상 (*)필수속성으로 받아온다.
- 배타관계를 받아오는 entity에서 3이상 中 택1의 속성이라면, <물리>에서는 (o)선택속성으로 가능 but 논리에서는 3 중 택1이라도 필수속성으로 묶어서 가져온다.
      
   3. 아크는 반드시 하나의 엔터티에만 속해야한다.(여러entity -> 하나의 entity)

      - 한 아크에, 배타관계를 받아오는 entity가 2개가 걸릴 수 없다.
        **Q. entity는 여러 arc를 가질 수 있다/없다 => 있다111**
        **Q. 관계는 여러 entity를 가질 수 있다.없다 =>  없다111**
        **Q. 아크는 여러 entity를 가질 수 있다.없다 =>  없다111**
        - 관계든, 아크든 하나의entity안에 속해야한다.

   4. 어떤 엔터티는 다수의 아크를 가질 수 있다. 그러나 지정된 관계는 단 하나의 아크에만 사용되어야한다.

      - 배타관계를 받아오는 하나의 entity에 여러 아크가 존재할 수 있다.
      - 배타관계들 하나의 묶음에서만 아크를 만들지, 서로 다른 베타관계들과 같이 아크를 만들 순 없다.

      ![](http://cfile25.uf.tistory.com/image/99179A395D28924916584D)