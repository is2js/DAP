# 논리 데이터 모델링

논리 데이터 모델링 순서(-속,엔,이-)(-식,정,M,참-)

1. 속성 정의
2. 엔터티 상세화
   - 식별자 확정
   - 정규화
   - M:M관계해소
   - 참조 무결성
3. 이력관리
   

## 제 1절 논리 데이터 모델링 이해

### 논리 데이터 모델 정의

* 논리적 데이터 모델링이란 **데이터베이스 설계** 프로세스의 **Input**
* **비즈니스 정보의 구조와 규칙을 명확하게 표현**하는 것
* 논리적 모델은 **데이터 모델링 최종적으로 완료된 상태(비즈니스가 다담김)**
* **물리적인 스키마 설계** 하기 **전 단계**
* **전산화와는 독립적**(전산화는 물리가 관리)
* **비즈니스 사실을 인지, 기록**하는 기법
* **데이터 모델링 과정의 핵심**



* 시스템 구축을 위해서
  * **기초 업무 조사 부터**
  * **인간이 결정**해야할 사항 **대부분을 정의**
  * 시스템 설계의 전과정을 지원하는 **과정의 도구**



### 논리 데이터 모델링 목적과 효과

* **비즈니스**에 대한 **데이터 구조 관점에서 명확한 이해**
* 전사적인, **통합적인 데이터 체계 확립** ex>사원Table은 부서별(X) 통합해서 1개만
* 데이터의 **일관성, 정확성 유지를 위한** **규칙 도출**
  * 전사적 데이터 구조 체계화와 통합
* **데이터베이스 설계의 토대**
* **의사소통을 위한 수단**으로 활용



### 논리 데이터 모델링 필수 성공요소

* 현업사용자와 모델링 진행(개발자x 현업실무자)
  - 개발자or시스템담당자 < 현업담당자
  - Process or 절차 < 데이터구조
* 절차(=프로세스=나쁜말)보다는 데이터에 초점
* 데이터 구조(비즈니스가 담긴 구조)와 무결성 함께 고려
* 개념화와 정규화 기법 적용
* 다이어 그램 이용
* 데이터 사전(표준용어, 표준단어) 구축



## 제 2절 속성 정의

### 속성 특징

* 속성 : 가공되지 않은 원천을 의미
* 속성도 집합이다. ex> 사람 속성 : 홍길동, 조재성, 김석영, ...
* 관계도 속성이다.
* 속성들간은 서로 독립적이다.
  * **속성들간에 종속 -> 제3정규화 위배**
  * **반복되는 유형 / 반복되는 값 -> 제1정규화 위배**
    ex> 병렬식 속성은 반복되는 유형 (계약자, 피보험자, 종피보험자1, 종피보험자2)



### 속성 후보도출

1. 속성 후보 수집처
   - 구 시스템의 문서자료
   - 협업 장표/보고서
   - 사용자와 협의
   - DFD(data Flow Diagram) / DD(data dictionary)
   - 전문서적 및 자료
   - **다른 시스템자료** (엔터티 후보, 주제영역 정의에서도 다른시스템 자료 활용!)
2. 속성 후보 선정 원칙
   - **원시 속성**은 **버리지 않는다.**
     - 다른 속성에 의해 다시 재현할수있는 가공(추출)속성이 아닌 속성
     - 추출속성 ex> 단가속성 * 금액속성의 합계, 고객등급
   - 소 그룹별로 후보군을 만들고 가장 근접한 엔터티에 할당한다.
3. 속성의 기본 구성요소
   - 속성명
     - **의미를 명확히 표현하는 명사구**를 사용한다
       ex> 일자X -> 사용일자, 매출일자
       ex> 부서코드X -> 매출부서코드
       ex> 사원번호X -> 매출사원번호
     - 업무에서 일반적으로 사용하는 용어를 사용
       ex> 사원(O), 직원(X)
     - 실체명(entity명)은 속성명으로 하지 말아야한다.
     - 필요시 표준약어를 제정하여 속성명 생성, 그 속성명을 단 하나의 실체에만 속하도록
       ex> 최고보험료 납입방법
       - 최고/보험/료 납입/방법/ 형식의 `표준 단어`로 짤라서 사용하는 것이 일반적
       - 필요하다면 `최고보험료 납입방법`자체를 `표준용어`로 제정
       - 그 에 따른 영어명칭 만들기 `first issurance fee input method`
       - 사용하기
   - **도메인( = 값의 범위 + data type과 length)**
     - 데이터 타입
     - 데이터 길이
     - 허용값(값의 범위) : 속성에 지정할 수 있는 모든 값들의 집합
     - 디폴트 값
   - 선택성( Not null/ Null )



### 속성 확정 요건 4가지111

1. **최소 단위(Atomic value)**까지 분할하라(일자 등 예외)
2. **하나의 값(Single value)**만을 가지는지 검증한다(사람당 1개의 값)
3. **추출 속성(Derived Atrribute)**인지 검증한다.
4. **보다 상세하게 관리**할 것인가?

> 엔터티 후보도출 요건 3가지
>
> 1. 개념정의 명확화
> 2. 우리가 관리할 것인가
> 3. 가로세로 면적
>
> 핵심엔터티 확정요건 5가지
>
> 1. 우리가 관리할 것인가
> 2. 가로세로 면적
> 3. 통합하기 위한 동질성이 있는가
> 4. 분리하기 위한 독립성이 있는가
> 5. 순수성(개체집합)인지 행위집합인지 짬뽕인지



#### 1. 최소 단위(Atomic Value)까지 분할

- 집합 개념은 단순 개념으로 분할한다
- 가능한 최소 단위까지 분할한 후, 필요에 따라 통합
- **일자, 시간, 성명, 주민번호, 우편번호, 주소** 등은 **일반적으로 분할하지 않는 것**이 좋다.
  - 년/월/일은 분할하지 않는다.
  - 시/분/초는 분할x
  - 성+이름은 분할x
  - 주민번호 앞뒤는 분할x
  - 우편번호 앞뒤는 분할x
  - **일시는 일자 + 시간로 분할**한다.
  - 보험계약entity에서 **#계약번호에 계약구분+일자가 포함**되어있다면?
    S-YYYYMMDD => 추출속성으로 **추출하지말고**,
    *년월일을 **따로 속성**으로 가져간다.
    *청약계약구분(S-, C-, P-)도 추출속성으로 하지말고, 따로 속성으로 가져간다.
- 통합과 분할은 업무 요구사항에 따른다.



#### 2. 하나의 값(Single Value)만을 가지는지 검증

**Single Value 검증** = **제 1정규화 위배** 검사
**`한 사람, 한 식별자 값에 대해 여러 개의 값을 가지는 속성(들)` / **
**`반복(병렬)되는, 같은 유형의 속성들`**은 ==>  **`묶어서 따로 엔터티를 만든다`**.
cf) 아크의 배타적인 관계를 가져올 때 ==> 필수속성(*)으로 가져온다.

![](http://cfile26.uf.tistory.com/image/99838D3E5D296C6A349AEE)





#### 3. 추출속성(Derived Attribute)인지 검증한다.

1. **현재** 정보만 관리시 : 현 주소, 고객등급(현재) -> 전체에서 현재의 정보만 추출한 것
2. **최초** 정보를 보관시 : 최초 가입일자, 최초 모집사원 ->  전체에서 최초 정보만 추출
3. **집계** 정보를 관리시 : 인원 수, 가족 수, 총직원 수 -> 전체에 sum 등을 통해 추출
4. **대표** 정보만 관리시 : 대표 전자메일 주소, 취미, 법인 대표자 정보 -> 전체에서 대표적인 것 추출
5. 다른속성의 **일부만 분리** : 성별, 결혼여부 -> 성별 중 F, M만 추출
6. 일부분만 추출값 : 인원 수, 법인 대표자 정보 



#### 4. 추출 속성 규칙

* **초기**에는 추출속성을 **중복으로만 생각해서, 표현하지 않을 것을 권고** 했지만,
  **현재**는 **추출속성(현 주소, 고객등급)은 기업관리자들이 관심을 보이는 속성으로 데이터 모델내 반드시 기수할 것을 권장**
* **도출(Derived)속성**이란 어떤 추가계산 작업을 수행함으로써 창출되는속성
  ex>고객등급 속성은 **많은 프로세스를 통해 계산하고 시간이 많이 걸려서 가져온 것**
       이런 것은 따로 속성으로 가져가야한다.
  * **경영층이 원하고 필요**로하는 대표 정보다
  * **사용자들의 요구사항**이 담긴 속성
* 계산(Calculated) 속성은 쉽게 계산해서 나오는 속성
* **도출 속성의 물리적 구현에 대한 것**은 **논리/ERD에서 관리하지 않는다.**
* **도출 속성**은 **기본키가 되어선 안된다.**



#### 속성 정의 시 유의사항

* 의미가 명확한 속성명칭 부여 ( 설명안해줘도 알 수 있게)
* 유일한 복합명사(일자X->매출일자, 상품X->매출상품)
* 단수형
* 표준단어 제정
* 작의적인 전용의 금지
  * 전용 : A용도로 만들어놓고, B용도로 사용해버리는 것
  * 전용 사례
    * 모델러가 속성의 의미를 추상적/모호하게 정의해놔서 -> 개발자들이 잘못 갖다씀
    * 개발막바지or운용중 인 시스템에, 새로운 사용자 요구사항으로 인해 새로운 속성 추가가 필요할 때 (기존 속성들 바꾸려고 각 속성에 대한 200명의 팀장에게 사인안받을려고)
    * ERP패키지에서, 미리, 갖다쓰기 위한 용도의 속성을 정의해두는 경우
      ex> 아크에서 entity로 들어오는 배타관계를 필수 속성들로 받아놨는데,
      이것들은 반복되는 유형의 속성들 & 분리된 외래키들이라 
      1정규화를 통해 따로 새로운 엔터티를 만들고, 구분이라는 하나의 외래키로 통합되어 버리는 속성을 전용 속성을 가져와서 쓴다.





## 제 3절 엔터티 상세화(식, 정, M, 참)

### 식별자(UID, Unique Identifier)

* 엔터티 내 모든 인스턴스(물리row)는 유일하게 구분되어야한다

* 유일성 보장

* **식별자 순서**

  1. 본질식별자 받기 (메인, 행위엔터티 - 행위는 무조건 자식이라...)
  2. 후보식별자 도출하기( not null & unique한 속성 )
  3. 대체식별자 확인하기( nullable & unique한 속성)
      ex>사원엔터티의 주민번호 --> 사원번호 대체가능하지만, nullable이라 불가
  4. 인조식별자 지정하기 (본질식별자에서 모자란 부분 채워서 식별하기or의미or내부적사용)
  5. 식별자확정

* **식별자** 

  * 본질 식별자(부모)

    * **Key엔터티**는 **부모가 없어 본질식별자X**(본질식별자 = key 엔터티 아님)

    * **`행위 엔터티`**는 무조건 **본질식별자** (**행위엔터티**의 **본질식별자로 부모를 찾아감**)

      main 엔터티도 대부분 본질식별자 받음

    * **절대 종속/상대 종속**

      * **절대 종속** : **태어나게** 하는 부모 엔터티와 관계
        ex> [카드]엔터티 => [고객]이, [상품]을 구매해서 [카드]가 태어났다.??
        ex> [카드사용]엔터티 => [가맹점]이 [카드]를 사용해서 [카드사용]이 태어났다
      * **상대 종속** : **탄생과는 관계 없으나, 관계를 맺고** 있는 것
        ex> [부서]---ㅡ<[사원]
        ex> [코드]엔터티들 ---ㅡ< [Many Table]에서 조회

    * **직접 종속/간접 종속**

      * 직접 종속 : 1촌
      * 간접 종속 : 할아버지(2촌)

    ![](http://cfile2.uf.tistory.com/image/9994493A5D298BF4161600)

    * 행위 엔터티의 본질식별자

      * 절대종속(부모자식) & 직접종속(1촌)인 것을 찾기 위해 (부모 찾아가기)

      * 행위 엔터티는 본질식별자를 항상 받는다

      * **행위 엔터티 내 부모의 본질식별자를 찾는 법**
        **`누가, 무엇을, 언제, 어디서`에 걸리는 `식별자`는 부모의 본질식별자**
        **`어떻게, 왜`**에 걸리는 것은 행위엔터티내의 **속성**일뿐
        ex> 고객이 카드를 사용--> 카드사용이 태어났다.

        [카드사용]entity
        #고객번호 -> 본질식별자
        #카드번호 -> 본질식별자

        ex> 가맹점에서 카드를 사용 -> 카드사용이 태어났다.

        [카드사용]
        #가맹점번호 -> 본질식별자
        #카드번호 -> 본질식별자

        ex> 고객이 대출상품을 구매해서 [대출]이 생겼다.
        [대출]entity
        #고객번호 -> 본질식별자
        #상품번호 -> 본질식별자
        ![](http://cfile25.uf.tistory.com/image/9917174F5D298F2D2298DC)

  * 후보 식별자 도출

    1. 각 인스턴스를 유일하게 식별
    2. 나머지 속성들을 직접 식별
    3. Not null
    4. 여러개 속성일 경우, 개념적으로는 유일해야한다
    5. 자주 변경되지 않아야한다.
       => 후보식별자 = 속성 중 식별자로 선택된 not null & unique
       => 대체식별자 = 속성에서 식별자가 못된 nullable & unique

  * 대체 식별자 : 속성에서 식별자가 못된 nullable & unique
    ex> [사원]엔터티의 주민번호 => nullable & unique, nullable해서 식별자는 못됨

  * 인조 식별자 지정

    * 최대한 범용적인 값 사용(별도로 만드는게 아니라 기존에 사용하던 것)
      ex> 사원번호, 상품코드, 은행코드, 국제적 분류체계 HS코드, 국가, 통화코드

    * 유일한 값을 만들기 위함(부모의 본질식별자로는 인스턴스 식별이 안될 때 만듬)

      - 본질식별자의 누가/무엇을/언제/어디서 중에 일부분으로는 식별안될 때, 나머지를 채우기 위해 인조식별자로 채운다.  
        ex> 본질식별자로 누가/무엇을,이 이마 나왔는데 식별안될 때,
              언제--> #대출일자  로 채운다.

      ![](http://cfile22.uf.tistory.com/image/99AFE6385D29956228B65E)

    * 하나의 인조 식별자 속성으로는 (부모의본질4가지 중)대체할 수 없는 형태를 주의한다.

      * 본질식별자의 어느부분을 대체하기 위한 인조식별자인지 명확화
        ex> 인조식별자로 만든 #일련번호는 본질식별자 #대출고객번호 #대출상품번호 이외에 어느 부분을 대체한 것인지를 알 수 없다.
        #대출일자를 #일련번호 대신 사용하면, [누가/무엇을/`언제`/어디서] 의 본질식별자 찾기방법중에 하나에 걸리며, 어느부분인지 명확화가 된다!!!
      * 예) 이력을 위한 #일련번호 인조식별자가 --> 자식에 상속될 경우,
        그 자식은 누가/무엇을/언제/어디서 에 하나도 안들어오면서
        자식의 #일련번호와 같은 유형이 반복되게 된다.
        ![](http://cfile6.uf.tistory.com/image/991AE9475D299A832297D1)

    * 편의성, 단순성 확보를 위해 인조식별자 만들기 가능

      * #주민번호처럼 13자리로 속성의 길이가 너무 길 때
        인조식별자로서 #사원번호를 만들어 대체할 수있다.

    * 의미 체계화를 위한 인조식별자 사용

      * ex> **S**-**201301**-012345-X , **YYMMDD**- ???
      * 특정한 의미를 부여한 인조식별자는 변별력을 향상시킨다.
        좋지도 나쁘지도 않는 인조식별자.

    * 내부적으로만 사용하는 인조식별자

      * 사용자들에게 알려주지 않는, 내부적으로만 사용되는 식별자
      * ex> 오라클DB에는 테이블명이 바뀔 것을 대비하여, 
        식별자를 부모에서 받은 본질식별자 #Owner를 사용하지 않고,
        테이블entity자체의 #TABLE.ID 식별자를 인조식별자로 사용한다.
        이렇게 하면 * 테이블명이 바뀌어도, 언제든지 해당 테이블에 접근
        테이블entity의 자식인 컬럼entity도, 테이블명바껴도 부모인 테이블entity를 찾아갈 수 있다.
        ![](http://cfile4.uf.tistory.com/image/99F1904C5D299BEE33070F)

  * **식별자 확정**

    * UID bar의 2가지 의미

      1. 자신의 식별자 

      2. 정보(부모, 할아버지 찾아갈 때,)

         - (main, action 중 )자식이 아닌 entity는 상대종속/참조관계로서,
           부모의 식별자를 #본질식별자가 아닌  ***일반속성으로만** 가지고 있다.
           이럴 경우, 자식entity에게 참조했던 entity정보를 못물려줘서,
           바로 찾아갈 수가 없다.
         - 부모에게 받은 본질식별자를 가질 경우, 자식에게도 본질식별자가 그대로 넘어간다. 그렇게 되면, 부모를 안타더라도 바로 #AA를 찾아갈 수 있다.

         ![](http://cfile25.uf.tistory.com/image/99DC1D465D299D992D4429)

    * 식별자 확정의 절차

      1. key 엔터티를 먼저 확정한다(인조식별자)
      2. main 엔터티를 확정한다.
         본질식별자를 많이 받아오고 + 모자란 부분은 인조식별자로 채우거나
         인조식별자를 새로 생성해버린다.
      3. action 엔터티는 무조건 본질식별자를 사용한다.

  * cf) SQLP에서 더 등장하는 식별자들

    * 복합식별자 (2개이상 모여서) <-> 단일 식별자(1개로)
    * 내부 식별자 (자신만의) <-> 외부 식별자 (부모에게 물려받는)

###  정규화

가. 정규화의 의미 

* 변경 이상 : (정규화 안되어 있을 시) 삽입, 수정, 삭제할 때 오류가 발생할 개연성을 가진다.
* 변경 이상이 발생하는 엔터티를 그대로 운영할 경우, 
  데이터가 신뢰할 수 없는 값으로 채워질 가능성이 높다.
  즉, 데이터의 일관성, 무결성이 위배될 가능성이 높다.
* 정규화 과정을 통해서 변경 이상의 엔터티를 정규화된 엔터티로 변환
  * 입력 이상 : 입력시, 원하지 않는 데이터도 입력할 경우 발생
  * 삭제 이상 : 삭제시, 유지되어야할 정보도 같이 삭제될 경우 발생
  * 갱신 이상 : 갱신시, 원하지 않는 정보의 이상현상 발생, 무결성 파괴, 정보의 모순성 바생

나. 정규화의 장점

* 중복값이 줄어든다
* NULL값이 줄어든다
* 복잡한 코드로 보완할 필요가 없어진다.
* 새로운 요구사항의 발견과정을 돕는다.
* 업무 규칙의 정밀한 포착을 보장한다
* 데이터 구조의 안정성을 최대화한다.



다. 정규화 단계

 1. **1차 정규형(Single value여야한다.)**

    * 정의

      * 모든 속성은 반드시 하나의 값을 가져야한다. 즉, 반복되는 형태가 있어서는 안된다.
      * 각 속성의 모든 값은 동일한 형식이어야한다.
      * 각 속성들은 유일한 이름을 가져야한다.
      * 레코드들은 서로 간에 식별 가능해야한다.
      * my) **한 사람, 한 식별자에 대해 나머지 속성들이  여러값을 가지는 경우,
               그 속성들을 묶어서 따로 **
               본질 식별자를 FK(외래키)로 받는**`자식 엔터티`로 뺀다.**
        ex> 한 고객번호(사람)당, O계약일 속성은 여러 개의 값을 가질 수 있다.
              => O계약일을 외래키로 가지는 entity를 따로 뺀다.
        ![](http://cfile27.uf.tistory.com/image/9998C5395D29B63E110978)

      

	2. 2차 정규화

    * 정의 : 

      * **식별자를 제외한 나머지 일반 속성들은, 식별자 `전체`에 종속되어야한다.**
        my) **1차 정규형을 통해** 본 엔터티 + **자식엔터티를 가진 상태**다.
               **`자식엔터티`는 #부모의 본질식별자, # 자식의 인조식별자로 모두에 동시종속**되어야한다.
        		**만약, 식별자 2개 중 1개를 가린상태에서 나머지 1개에만 종속가능하다면**,
                **2차 정규화 대상**이다.
         ex ) 학과등록entity에서, #학번을 가려보자.
        		#코스코드 1개에만 종속인 것은 *코스명, *기간이다.
        		#코스코드를 가려보자.
        		#학번에만 종속인 것은 *평가코드, *평가내역 이다.
         my)  **2차 정규화 결과, `자식엔터티`는 `또다른 부모엔터티`를 가지게 된다. 이 때**,
                **자식의 `#인조식별자에 해당하는 부분종속 식별자`와 `거기에 종속되는 속성들을 모두` 가지고 `부모엔터티로`올라간다**.

      * 물리 모델로 말하면, 기본키를 제외한 나머지 컬럼들은 기본키에 종속적이어야한다.

        ![](http://cfile5.uf.tistory.com/image/998DDB495D29B77E09DC17)

	3. 3차 정규화

    * 정의

      * 2차 정규형을 만족해야한다( 1차:Single Value, 2차:식별자 전체종속)

        - 1차 결과 : 자식을 가짐
        - 2차 결과 : 자식에서 또다른 부모를 가짐

      * 식별자를 제외한, **일반 속성들간에 종속이 존재**하면 안된다.
        ex> 2차 정규화 결과, 부모2-자식1이 생겼다.
              자식entity에서 나머지속성들을 보면
              *평가코드는 --> *평가내역을 결정하는 종속관계이다.
         **my) 일반속성들끼리 종속을 가지면, 통째로 가져가서 `참조관계의 상위엔터티`를 만들고, `그 중 식별자를 정해 외래키`로 받아온다.**
        ![](http://cfile9.uf.tistory.com/image/996AB6435D29BEEB0B886A)

        즉,  학과등록entity에 *평가코드 -> *평가내역이므로,
        2개의 속성을 가져와 참조관계의 상위엔터티 [평가항목]을 만든 뒤, 
        #평가코드를 --> *평가코드(FK)로 받아온다.



### 1,2,3차 정규화 복습

* 전체 사진
  ![](http://cfile9.uf.tistory.com/image/997658505D29C18A1BA483)

* 1차 정규화

  - **1차 정규형(Single value여야한다.)**

  - 한 식별자(사람, 고객)에 대해 **반복되는=여러 값(데이터)을 가지면 안된다.**

  - 한 식별자에 대해 **반복되는(=비슷한) 유형의 속성들을 병렬식으로 가지면 안된다.**

  - **그 속성들을 묶어서 `자식엔터티`로 빼고, `부모의 본질식별자를 FK`로 준다.**
    [고객]entity는 한 고객에 대해서, **여러** 주문상품,주문상품명,주문일자,상품유형코드,상품유형명을 가진다.
    => 이 속성들을 묶어서, 자식엔터티 [주문]entity로 빼고,
    => 부모entity의 #고객번호를 #주문고객번호(FK)로 뺀다.

    ![](http://cfile22.uf.tistory.com/image/993DD4495D29C1931CBB02)

  

* 2차 정규화

  - 식별자를 제외한 **일반속성들을, 식별자 전체에 종속**이어야한다

  - 만약, 2개의 식별자를 가진상태라면, 한 식별자를 가리고 나머지 한 식별자에만 종속되는지 확인한다. 

  - `일부종속을 만드는 #인조식별자` + `거기에만 종속되는 속성들`을 가지고 **`부모엔터티`**를 만든다.

  - [주문]entity의 #주문고객번호(1차결과의 본질식별자) + # 주문상품코드(인조식별자)를 가지는데, **#주문상품코드에`만`** 종속되는, 상품관련 일반속성들이 있다. (*주문상품명, *상품유형코드, *상품유형명)

    = > `# + ***`를 가지고 `부모엔터티`로 올라간다. 
    => 부모로 갈 때는, 자식관련=주문관련 용어는 뺀다. #주문상품코드는 본질식별자(FK)로 남는다

    ![](http://cfile24.uf.tistory.com/image/99EA8D425D29C1A1274073)

* 3차 정규화

  - 식별자를 제외한, **일반속성들 간에 종속이 존재하면 안된다**.

  - **일반 속성들간 종속이 존재하면, 통째로 가져와  `참조관계의 상위엔터티`를 만들고, X->Y 중 X를 식별자**로 하고, 하위엔터티에 외래키로 보낸다.

  - [상품]entity는 일반속성인 *상품유형코드 -> *상품유형명 간에 종속이 존재한다.
    2 속성을 묶어서 참조관계의 상위엔터티 [상품유형]entity를 만들고,
    *상품유형코드를 식별자로 정하며, 하위 [상품]entity에다가 *필수속서의 외래키로 준다.

    ![](http://cfile24.uf.tistory.com/image/9969C0485D29C1AD28FC0A)