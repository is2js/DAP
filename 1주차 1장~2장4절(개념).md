# 1장 데이터 모델링

**\*\*\*데이터 모델의 정의** : **현실세계에 대해 `우리가 관심있어`하는 대상을 `데이터베이스화`하기 위한 개념적 도구111**

**종류** : 

1. **개념 데이터 모델링** : 합참의장 - 참모총장 - 사령부 - ... - 사단까지 / 쉽게 생성 가능, 이후 논리부터 분해(상세화 된다)
   - 주제영역 정의 -> 주제영역내의 핵심엔터티(key, main) 도출 -> 그달간의 관계를 정의
2. **논리 데이터 모델링** : 대령 - 중령 - ... - 병장 까지 / Entity라 부름. 
3. **물리 데이터 모델링** : 각 DBMS의 기준에 맞추어서 논리 데이터 모델링을 전환한 것 / Table이라 부름.



**표기법** 

1. 바커 표기법 : `#` (key), `*`: mandatory, `o`: optional / `sub-type`을 내부에서 쉽게 표현, 속성은 최하위의 요소들 
2. 정보공학적 표기법 : SQLD에서 보던 표기법 / `subtype`작성은 밖에서 표현(X가 달린 것이 mandatory)



## 제 1절 데이터 모델링 이해

**IT 개발 방법론의 발전방향** : 

* 1970 구조적 방법론 :  프로그램 자체가 중요
* **1980 정보공학적 방법론(Information Engineering)** : 데이터가 중요
* 1990 CBD 방법론 : process + data 모두 중요. 



### 데이터 모델링 정의

1. 데이터 모델링 탄생 배경

   * **중복 없이** 정확하게 유지 ex> 반정규화로 속성을 갖다붙혀서 join안하는 것...은 중복이다..
   * 정확한 업무 파악(**데이터에 대한 정확한 분석**)
   * **현실세계** 잘 표현할 수 있을까?에 대한 답으로 **ERD**로 표현

2. **데이터 모델의 정의** : **현실세계에 대해 우리가 관심있어 하는 대상을 데이터베이스화하기 위한 개념적 도구**

3. 모델링의 정의

   * 실체를 나타내는 일과 **모형화**

   * 모델이란? 현실세계의 **추상화(=논리적 표현)**된 반영

   * **즉, 업무에 대한 종합적 이해를 바탕으로, 업무 규칙(Biz Rule)에 대해 참/거짓을 판별할 수 있는 사실을 정의. **

   * **어떻게(HOW), 누가(WHO) 접근하는지는 상관없다. (전산화랑 상관없다)**

   * **현 업무파악으로 문제점 인식  +  개선사항 도출 +  적합한 설계를 위해, 인간이 해야할 대부분의 결정을 내리는 단계까지 포함하는 것**

     **\*\*\*프로세스 = 나쁜말**

4. 데이터 모델이 제공하는 것 (-가, 명, 틀, 문, 관, 세-)

   - 시스템을 **가시화**
   - 시스템 구조와 행동을 **명세화**
   - 시스템 구축하는 틀 제공
   - 결정한 것을 **문서화**
   - 집중하기 위해 다른 영역의 세부사항을 숨기는 **다양한 관점** 제공(개괄 데이터 모델)
   - 목표에 따른 다양한 **상세수준 제공**

   **\*\*\*주제영역을 기점으로 **

   **`上 : 개괄 데이터 모델` / `內 : 핵심 엔터티 도출의 개념 데이터 모델` / `下 : 논리 데이터 모델`***

   

### 데이터 모델링 필요성

* 고품질 데이터 모델 -> **안정성, 유연성, 성능**에 영향 / 시스템 개발의 가장 **핵심적인 과정**

* **프로세스(세모)** 중심적인 시스템 구축 방법 -> **정보 공유 문제점 발생 / 데이터 무결성에 좋지 않음 / 데이터 품질에 악영향**
  ex> **프로세스별**로 따로 개발하게 되면 각 시스템마다 **`사원TABLE`이 따로 생기게 된다**.
         **정보의 고립화 / 데이터 중복 / 데이터 무결성 문제 발생**

  => 기능별 시스템을 가로지르는 **데이터 통합이 중요**

* 데이터 모델링(설계)가 중요한 이유

  1. **파급효과** : 테스트 시점에서의 변경은 많은 비용 초래
  2. **간결한** **표현** : 복잡한 현실세계를 간결한 DB로 표현 가능
  3. **데이터 품질**

가. 애플리케이션과 데이터의 통합

* 앱 코딩 차원의 통합은 많은 비용 초래
* **데이터 기반으로 한 통합이 필요** -> 효과적, 저비용, 안정적

나. 개발자들의 시스템 이해 

* 시스템+데이터의 확실한 이해를 위해, 데이터 모형화가 필요하다
  1. 사용자 관점 데이터 : 사용자가 원하는 것 : 논리적 개념 --> 시스템이 그것을 제공 : 물리적 개념
  2. 물리적 표현or사용에 관계없이 데이터 그자체가 본질이다.
     - 저장기법, 접근방법, 데이터사용자와 사용법과는 무관하게 데이터 자체가 본질

다. **\*\*\*데이터 모델링시 주의점(-중, 비, 비-)111**

1. **중복(Duplication)**	

 	2. **비유연성(Inflexibility)** 
     ex> 처음부터 보험의 관계자를 3명만 설계(보험계약자, 피보험자1, 피보험자2)할 경우,  사람을 추가할 수 없다. 그러지 말고, `보험관계자`테이블을 따로 만들어  *관계유형 : 보험계약자 or 피보험자  으로 유연성있게 바꿀 수 있다.
 	3. **비일관성(Inconsistency)** : 여기는 있는데, 저기는 없는 경우



### 데이터 모델링 단계

1. `개념 데이터 모델링`
   - **주제영역 정의 : 부서를 나누는 것으로 생각하자.**
   - **주제영역내 핵심엔터티 도출 : key, main entity 도출**
   - **엔터티들간의 관계 정의**
2. **`논리 데이터 모델링의 순서111`\*\*\*(- 속, 엔, 이-)(-엔 : 식, 정, M, 참)**
   - **속**성 정의
   - **엔**터티 상세화(4)
     - **식**별자 확정
     - **정**규화
     - **M**:N 관계 제거
     - **참**조 무결성 정의
   - **이**력관리
3. **`물리 데이터 모델링의 순서111`**
   - **논리->물리 변**환(논리에서 이미 비지니스 룰 다 반영, 물리에서는 변환만) / 
   - **반**정규화

### 모델링의 기본 3원칙111

**\*\*\*(-커뮤니케이션, 모델링 상세화, 논리적표현-)111**

1. **커뮤니케이션 원칙** : **이해당사자들끼리 동일한 ERD를 그려놓고 이야기**하면, 서로 다르게 이해하는 문제가 해결

2. **모델링 상세화 원칙** : 비즈니스 담당자와 비즈니스 룰을 적용하여,  ** 현업의 요구사항들이 다 반영되어서 DB화 시켜놓은 것이 논리 데이터 모델링!  논리 모델링이 끝나면 모델링이 다 끝난 것이다.** (물리 데이터 모델링의 TABLE과 상세수준이 같음)
   - 데이터 본질과 잠재적 사용을 이해할 수 있을 만큼 상세화
   - 논리 데이터 모델에서 이미,  물리 단계의 TABLE까지 상세 수준이 상세화가 필요
     ex> 사원테이블에서 사원구분-> **sub-type**으로 (정규직, 비정규직, 임시직) **상세화**
     ex> 고객테이블에서 개인/법인 구분을 -> **sub-type**으로 (개인, 법인) **상세화**
   - **논리 모델 -> 물리 모델**은  **분해(X) 변환**만! ( 이미 논리에서 상세화 끝)

3. **논리적 표현 원칙** : **논리** 데이터 모델링을 **거쳐서** **Entity로 추상화**를 한 다음에, 물리 단계로
   - **비즈니스를 제대로 반영해서 DB구조화하는데 신경쓰자.(퍼포먼스 신경쓰지말아라. 웹이라면, 그 화면구성을 생각) + 무결성을 생각하자**
   - 논리 모델은 독립적
   - 사용자가 원하는 것에 근거를 두어야함
   - 논리적 설계와 물리적 설계를 구별해야한다( 물리로 바로 가지 말아야 함)





## 제 2절 데이터 모델링 기법 이해

### 데이터 모델 목적

- DB설계에 대한 **계획 또는 청사진**
- **설계자, 개발자, 사용자** 등 관련자들이 **데이터 구조에 대한 형상을 이해,**  **원활한 의사소통**을 할 수 있다 (커뮤니케이션의 원칙)
- 서로 다르게 인식하고 있는 **뷰들을 하나로 통합**할 수 있는 **단일화된 설계안** 만듦
- **요구사항 정의**



### 개체-관계 모델 기법( Entity - Relationship Modeling)

- 피터 첸에 의해 1976년 최초 제안
- 개체-관계 모델은 표준 데이터 모델로 부상
- 개념/논리 데이터 모델링에서 가장 일반적으로 사용
- **서브타입이 추가되**면서 확장된 개체-관계 모델(Extended ERD)가 만들어 졌음
  - 요즘 ERD는 모두 E-ERD



 ERD Model을 사용하는 목적

- 관리자, 사용자, 개발자들의 뷰를 하나로 통합할 수 있는 단일화된 설계안 작성

- 요구사항을 정의

  

### 개체-관계 모델 구성요소

- 엔터티(Entity)  : TABEL과 대응

  - `Key Entity` , `Main Entity` : 핵심엔터티 in 개념 데이터모델 / `Action Entity` in 논리 데이터 모델에서 분해되는 것
  - key : 부모가 없는 신 같은 엔터티
  - action : 개념에서는 도출안하며, 논리에서 하나씩 분해되는 엔터티

- 속성(Attibute) :  Column과 대응

- **식별자(Identifier) : Primary key**

- 관계(Relationship)

- **존재 종속 : 부모-자식 관계** **(- 누가 무엇을 해서,   태어나게 하면 -)**
  ex> 고객 / 상품 / 카드 entity가 있다면, < 누가? 무엇을? 어떻게? > 의 관계를 보자.
          **`고객`**이 **`상품`**을 가입해서 --->  **`카드`**가 **태어난다.**
          고객, 상품 : 부모 ---> 카드 : 자식의 **존재 종속**
  ex> 사원 / 부서 entity가 있다면,
          사원이 ??해서 부서를 **태어나게 한다? (X)**
          부서가 ??해서 사원을 **태어나게 한다? (X)** => **부모자식(X), 존재종속(X)**
          사원보다는 **부서가 먼저 생긴다. [부서]---**ㅡ[사원] 
           한 사원이 여러부서?(X) **한 부서에 여러 사원(O). [부서]---ㅡ<[사원]**

  (- 부모-자식의 존재종속이 아니라면,  **선/후와 1:N관계를 생각**해보자. -)

  ex> 사원 entity에서 `sub-type`인 사원구분  : 정직원 or 임시직 -->      

- **서브 타입 : 베타적(Exclusive)** 또는 **포괄적(Inclusive)** 일 수 있다.





## 제 3절 데이터 모델링 표기법 이해

표기법의 종류

1. 바커 표기법(Baker Notation)
   - Richard Barker 등 여러명이 개발
   - 이후 리차드 바커에 의해 지속적 업그레이드
   - 오라클 Case Method로 채택
2. I/E 표기법(Information Engineering Notation)
   - Clive Finkelstein과 James Martin이 공동저술
   - James Martin에 의해 체계 정리되면서 본격 활용
   - 까마귀 발 모델(Crow's Foot Model)이라고도 불림



### 바커 표기법

![](http://cfile21.uf.tistory.com/image/990889405D1DE6BB3280C4)

1. **점선데이터가 먼저** 생긴다. (부서 -> 사원 순으로 생긴다.)

   - 먼저 생긴 점선 : **부서에** 사원이 있을 수도 있고 없을 수도 있다

   - 점선(optional) vs 실선(mandatory)
   - 만약, 신입사원으로서, 부서 발령이 아직 안났다면, 신입--- ---부서의 둘다 optional
      : 신입사원은 부서가 있을 수도 없을 수도 있다.

2.  부서의 **#부서코드** --> 사원의 ***부서코드(일반속성)**으로 : `비식별자관계(─)` 

   - 부서의 #부서코드 --> 사원의 #부서코드(식별자)로 간다면 `식별자관계(┼)`
   - my) 만약 관계의 끝에 `식별자관계`표기라면? # -> `#` (주식별자)으로 간다
   - my) 만약 관계의 끝에 `비식별자관계`표기라면? # -> `*` (일반속성)로 간다

3.  재귀관계 : #부서코드를 다시 받는다.(부모에서 X)

4.  1:N  vs  1:1관계 :  한명의 사원이 여러 부양가족을 ?( O )  < (1:M)
                                   한명의 직원이 여러 부서를? (X) - (1:1)





![](http://cfile24.uf.tistory.com/image/996EA8375D1DE6C422AC79)

바커표기법의 `sub-type`은 마지막 요소들이 속성이 되며, 실제 데이터 TABLE에 다 표기 된다.

`sub-type`을 정보공학적으로 표현하면, **베타적**은 **X**를 , **포괄적**은 **빈칸**을 가지고 있다.

![](http://cfile5.uf.tistory.com/image/994009365D1DE6D52CB8AD)



### ※ 서브타입 관련 문구

- 제2절 데이터 모델링 기법 이해 - 사. 서브타입 : 
  **서브타입은` 베타적` 또는 `포괄적` 일 수 있다.**
  - **베타적** : 서브타입 하위 4개 중 **1개만 선택 가능**
  - **포괄적** : 서브타입 하위 4개 중 **2개 이상 가능**

- 제3절 데이터 모델링 표기법 이해 - 1. 바커 표기법 - 마. 서브타입 : 
  **서브타입은 서브타입의 중복을 허락하지 않는 `상호 배타적`이다.**
  - **바커표기법에서만 상호베타적!으로 암기 **/ `일반적으로는 베타적or포괄적!`

- 제3절 데이터 모델링 표기법 이해 - 2. I/E 표기법 - 마. 서브타입
  **서브타입은 `배타적` 또는 `포괄적`일 수 있다.**



# 2장 개념 데이터 모델링

**개념 데이터 모델링 순서111** : 

- **주제영역 도출**(부서나누기)
- **후보 엔터티 선정**111
- **수집된 엔터티 분류1**11
  1) 우선적용대상 원칙
  2)  데이터영역별 분류 : 
- **핵심 엔터티 정의**111
- **핵심 엔터티 관계 설정1**11



## 제 1절 개념 데이터 모델 이해

### 개념 데이터 모델 정의

- 주요 핵심엔터티(key, main)들로 구성
- **`핵심 엔터티`**란 **행위의 주체나 목적물이 되는 개체 집합** cf)신용카드 : 개체집합 / 사원 : 행위집합
  - **Key** Entity : 사원, 고객, 상품 같이  **행위의 `주체` or `목적물`**이 되는 것 / 신과 같아서 부모가 없다.
    ex> 사원이 ~ , 고객이 ~,  A가 상품을 ~ 
  - **Main** Entity : 행위의 **`주체`** or **`목적물`** or **`언제`**했는지 에 걸리는 entity
    ex> **`신용카드`** : **고객**이 / **상품**을 가입해서 / **신용카드**가 **태어났다.**
           -> **부모-자식관계 ( 존재 종속 )**을 해석하는 것임
           **`신용카드`** : **고객**이 **신용카드**를 ?? 
           -> 주체나 **목적물**이 된다.
  - **Action** Entity : 행위의 주체, 목적물, 언제에 **`뭐를 했는지`** /  A가 B를 **C한다**.
- 부모가 존재하지 않는 창조된 집합(신) -> Key entity
- 다른 집합의 존재 유무에 상관없이 독립적으로 탄생
- 핵심엔터티는 대체적으로 여러가지 하위의 행위 엔터티를 탄생시킨다.

![](http://cfile7.uf.tistory.com/image/99F6F73B5D1DF54E1B880D)

- 고객, 상품, 가맹점 Entity는 부모가 없는 Key엔터티다 ex> 고객이 상품을
- 카드는 대표적인 Main엔터티다. ex> 고객이 카드를 ~



### 개념 데이터 모델 의의

- 주요 엔터티로 한정 지을 뿐, 논리 모델링과 똑같다
- 개념 모델링으로 핵심 엔터티들은 관계만 가지도록 하며, 
  분해(쪼개)지는 것은 이후의 논리 모델링에서다.
- 개념 데이터 모델링도 상세화가 진행될 수 있다.  
  = **개념 데이터 모델링에서는 `sub-type`으로 상세화** 한다.
- 상세화 되더라도 전체적인 골격의 개념적 모델을 벗어나진 않는다.



### 데이터 아키텍처 프레임워크 상에서 개념 데이터 모델

- 개괄 데이터 모델 : 주제영역(부서나누기)보다 상위
- 개념 데이터 모델 : 주제영역 하위(내부)



## 제 2절 주제영역 정의



### 주제영역 개념\*\*\*(-원기,방,목장,명)

원(칙), 기(준) /  방(법) / 목(적) / 장(점) / 명(명)

- 기업 데이터의 **최상위 집합( 인사, 생산, 자재, 판매  등) --> 부서라고 생각하자!**
- 주제영역 내부(부서별로 서로) 데이터의 관계는 밀접 <-> 다른 주제영역(다른 부서)와는 상호작용 최소화
  -> **높은 응집도 / 낮은 결합도**
- 데이터는 관계구조로 표현
- **`관계구조`**는 관계가 복수 개로 연결되어 **하향식 분석(주제영역->key->main순)이 용이하지 않음**
- **`계획 수립단계`**시에만 **하향식 분석**을 원칙으로 함
- **`검증`**시에는 **상향식 분석**을 사용
- **`주제영역`**은 **하향식 분석시 유리** 
  (**주제영역을 계층적으로 분해한 -> 하위주제영역 -> Entity**)
  my) 계획수립단계, 주제영역 정의시 하향식  /  관계구조, 검증시 상향식



cf) **`아크`** = **관계가 베타적(택1)**인 것 ->  **`통합`**한다
ex> 개인entity / 법인entity --> 계좌entity 관계에서, 개인과 법인은 베타적이다.
       **베타적일때는 고객Entity로 통합**해버린다.

![](http://cfile5.uf.tistory.com/image/99CB5C495D1DF975460B04)



### 주제영역 분류 원칙 및 기준111

가. **주제영역 분류 원칙111**

- **중복 최소화**
- **데이터 확장성 보장**
- **관련성 및 편의성 제공**

나. **주제영역 분류 기준111**

1. **데이터 관점**에서 분류(프로세스x)
   - 주체, 목적물(key) 및 행위(action) 등 **데이터를 생성시키고 사용하는 유형에 근거**
   - **전사적인 관점**에서 데이터 유사성 고려
   - 시스템과 어플리케이션이 다르더라도 **동일한 유형의 데이터를 유사한 방식으로 사용한다면 통합된 관점에서 데이터 관리**
2. 업무 추가에 대한 **유연성 보장**
3. 주제영역간 **균형유지** ex> 각 주제영역별로 entity 개수가 동일해야한다.
   

다. 주제영역 **명명(** 명명 = 이름 = 커뮤니케이션의 원칙 -> ERD그려놓고 이야기)

1. 실업무의 **보편적 용어**
2. **단수**형 명사
3. **데이터 그룹(주제영역)을 의미**하는 용어



### 주제영역 활용

가. 목적

- 계층적 구조 파악에 도움
- 최상위 단위 역할을 하므로 품질 확보에 기여
- 데이터 구성에 대한 청사진
- 데이터 구성 및 통방에 대한 방향 제시(선언적 성격)
- 효율적 데이터 관리 기준 제공



나. **장점111 ( 데이터 퍼포먼스 = 개발의 효율성 = 생산성) 과는 관련없다.!**

- 품질보증
- 프로젝트 관리 용이
- 개발 조정 용이
- 리포지터리 관리 용이
- 상세한 전개 혹은 축약 가능
  **\*\*\* 주제영역은 `생산성`과는 무관하다!111**

### 주제영역 도출

가. 데이터의 **명사형 도출111**

나. 업무 **기능의 이름111으로부터 도출**

다. **하향식(top-down방식)111** 접근 방법으로 도출

- **주제영역 -> 하위 주제영역 -> ,,, -> 엔터티 **으로 전개111

라. **상향식** 접근 방법으로 도출

- 엔터티 타입을 그룹핑 -> 주제영역 도출

마. **분석단계**에서 도출

- 아키텍쳐 모델 정련과정에서 도출
- 데이터 모델 상세화 과정에서 도출





## 제 3절 후보 엔터티 선정

### 개념

- **후보의 자격여부만 판별**
- 실제 엔터티를 **확정하는 별도의 단계는 따로 있다.**



### 엔터티 후보 수집

- 기존 시스템 문서
- 현업 장표 / 보고서
- 현업 인터뷰
- 관련 전문 서적
- 데이터 흐름도(DFD)
- \***\*\*타 시스템 자료** - 또한 주제영역의 후보이다
- 현장조사



### 엔터티 후보 식별 (\*\*\*후보 엔터티 요건 3가지)111

- 후보에 대한 **개념정립을 명확화** 한다.111
  ex> 사원Entity의 후보를 만들 때,  정규직만 개념에 포함시킬 것인지 / 임시직, 협력사 다 포함 시킬 것인지 개념 정립
  ex> 고객entity - 개인고객만 있는지 / 법인고객도 같이 있는지 명확하해야한다.
- **우리가 관리하고자 하는 것**인지 따져 본다.111
- **가로와 세로를 가진 면적(집합)인지 확인**한다. 111
  = 가로 : 속성2개이상 / 세로(논리instance -> 물리row) :  레코드 2개 이상의 데이터 인지 확인



### 엔터티 후보 선정시 유의사항(\*\*\*)111

(-깊, 모, 가, 동 / 예, 프, 단 -)

1. 너무 **깊**게 들어가지마라 (지금은 개념 데이터 모델링)
2. **모**호한 대상은 개념을 상식화하여 이해하라(회사에서만 쓰는 대상을 공공화?)
3. **가**능성이 있다면 바로 검토대상에 올려라
4. **동**의어처럼 보이더라도 함부러 버리지마라
5. **예**외 경우에 집착하지마라
6. **프**로세스에 연연해 하지마라
7. **단**어 하나하나에 집중해서 판단해라



### 수집된 (후보)엔터티 분류111

**가. 우선 적용 대상** **분류111 **( **개념**단계이므로 **우선 적용 대상 : key, main**만 찾아서 분류)
     **-> 하는 이유111 : action 엔터티는 배제하기 위해서!!!**111

1. **키** 엔터티 : 행위 **주체나 목적어**
   ex> 사원**이**, 부서**를,** 고객**이,** 상품**을**, 자재**를**

2. **메인** 엔터티 : **키 엔터티보다 더 하위** 행위를 발생시키는 **주체나 목적어**

   **my) 부모를 가지는 주체나 목적어**
   ex> 보험계약**을** / 사고**가** / 예금원장**이** / 청구**를**

3. 액션 엔터티 : **주체나 목적어 이외의 나머지** 엔터티 전부 my) ~가 ~를 한 **내역**
   ex> 상태**이력** / 차량수리**내역** / 상세주문 **내역**

**나. 데이터 영역별 분류 **111
      **-> 하는 이유111: *\*\*통합과 분할의 기초자료111로 활용하기 위함**
    ex>법인고객entity 개인고객 entity ->고객이라는 동질성으로 통합 

1. 사람 : 사원, 가입자, 회원, 고객, 학생 교사
2. 물건 : 부품, 원재료, 연료, 저장품
3. 사건 : 계약, 수주, 주문, 발주, 재해
4. 장소  : 참고, 생산라인, 행적구역, 하천, 선거구



## 제 4절 핵심 엔터티 정의

### 핵심 엔터티 정의 요건(5) -> 엔터티 확정의 5가지111 \*\*\*

1. **우리가 관리하고자 하는 것**인지 확인(후보요건 2)111
2. **가로와 세로의 면적**인지 확인(후보요건 3)111
3. **개체간 동질성**이 있는지 확인 -> **통합하기위한 동질성이 있는 것**이냐111
   ex> 학생-강사 --> 사람entity로 통합 / 개인-법인 --> 고객entity로 통합
4. 다른개체와 구분되는 **독립성**을 가지는지 확인 -> **분리하기위한 독립성이 있는 것**이냐111  
   ex> 고객-사원 --> 하는 일이 다르므로 독립성을 가져 통합X
5. **순수성**인지 **행위집합(action entity)**은 아닌지 확인 -> **개체 + 행위의 짬봉은 아닌지**111
   - 순수성이 아닌 것 : 납입(행위집합) + 자(개체집합)이 합쳐진 것
     ex> 납입+자 / 불량거래+자 / 거래+자 ---> 이렇게 **개체+행위가 합쳐진 entity**일 경우
            **사람 1명을 찾을 때**,  납입+자 에서 검색1번 / 불량거래+자에서 검색2 / 거래+자에서 검색3 ---> **~자 가 붙은 entity 모두 총 3번을 검색해야한다**.
   - 개체 집합 ex> 고객, 사원, 상품
   - 행위 집합은 Action Entity로서, 핵심엔터티(key, main)에 속하지 않으므로 배제한다
     ex> 계약, 주문, 내력, 이력

> 후보엔터티의 요건 3가지 \*\*\*
>
> 1. 개념 정의가 명확한지
> 2. 관리하고자 하는 것인지
> 3. 가로와 세로의 면적인지 



### 의미상 주어 정의

가. **`본질 식별자`** 정의의 의의 (물리 모델 - PK)

- 집합의 의미가 모호한 상태에서는 판단 진행이 불가능하다
- **집합의 의미를 명확하게 해준다.**



**cf) 식별자의 종류111**

1. **`본질 식별자`** : **부모entity(누가,무엇을해서--> 해당 entity가 태어남)**에서 그**대로 물려받은 식별자** / **`uid_bar`** = **`식별자관계(┼)`**를 만들어준다
   * **`인조 식별자`** 
     - **`Main Entity`**인데, 부모로부터 물려받다가 **자식이 너무 많은 본질 식별자를 가질 때 (시험에서는 주어졌을 때)** 
     - **`Key Entity`**의 식별자는 부모가 없으니, 무조건 **인조식별자**일 수밖에 
       \*인조 식별자를 사용한 entity는 Join을 통하여 부모를 찾아가기힘들다.
   * **`Main entity, key entity`**는 **원칙은 본질식별자**
   * **`Action entity`는 무조건 본질식별자** : ERD그릴 때! 주의하자!
2. **후보 식별자** :  사원Entity의 주민등록번호 같은 ...
   <-> **대체 식별자**
3. **실질 식별자 : 실제로 # 표시가 붙은 식별자들**



cf) **식별자관점에서 그려보기*****

- **Main** Entity(**부모가 있는 주체,목적물**)은  **부모의 식별자/uid_bar/본질식별자를 다 사용**해야한다.

- **Key** Entity는 부모가 없어서 받을 식별자가 없으니 **인조식별자**다

- 부모가 있는 **Main(부모있는 주체,목적물) / Action(나머지)** Entity는 **부모를 가지므로 본질식별자를 무조건 써야**한다.
  그러나 **Main** Entity의 경우, 타고내려다가다가 **너무 많은 본질식별자를 가지게 될 때**,

  join시 필요한 식별자가 너무 많아지므로, **`인조식별자`를 만들고 부모의 본직식별자를 일반속성으로 사용**할 수 있다. 이 때는**, `uid_bar/식별자관계(┼)가 끊어진다`**면서 
  그러나 join을 통해 부모를 찾아가는 것은 어려워진다.

  

![](http://cfile28.uf.tistory.com/image/99C040375D1E0B982641DC)

고객과 상품을 통해 카드 entity가 태어났다. **카드**는 **부모를 가진 주체/목적물인 Main** Entity이다.  그러므로 **2 부모의 식별자를 모두 사용해서 본질식별자가 2개**가 된다.



![](http://cfile25.uf.tistory.com/image/997295425D1E0D7A2F21AC)

A, B의 자식 --> C 의 자식 --> E 에서
C는 부모 A, B의 식별자를 모두 사용해야하므로 본질식별자(uid_bar/식별자관계)를 2개 가지며, 자신의 식별자 또한 가지고 있다.

E는 부모인 C에 있는 식별자 #AA, #BB, #CC를 모두 본질식별자로 가져야하므로 
자신(#EE)의 식별자가 4개가 된다.  
이 때, **uid_bar/식별자관계를 끊고 = 부모의 식별자를 일반속성으로 두어서 인조식별자(#EE)만 사용**할 수 있다.





**나. 본질식별자 정의의 예시**

- 신용카드 엔터티(자식)의 상품과 고객 속성은 부모에게서 상속받은 릴레이션쉽
- 본질식별자로 상속관계를 규명해 올라갔 을 때 최상위는 키 엔터티(부모가 없는 신)
  - 의미상의 **주어 = 부모** ex> 고객**이** 상품**을** 가입하여  **신용카드가 탄생했다**.
  - **`의미상의 주어`를 이용해서 부모를 찾아가자!!!*****
- **주의할 점** : 1:M관계에서  1쪽이 항상 본질식별자가 되는 것은 아니다.
  - **`관계종속`(참조) vs `존재종속`(부모-자식) 감별하는 방법*****
    부서---ㅡ사원 : 부서가 **없어지면** 사원이 **없어진다**?  (X) => 관계종속
    사원---ㅡ부양가족 : 사원이 **없어지면** 부양가족이 **없어진다?** (O) => **존재종속 (부모-자식)** => **본질식별자 / uid_bar/ 식별자관계**
    ![](http://cfile23.uf.tistory.com/image/99B8D53F5D1E11A705E7AF)

- 본질식별자란? 없다면 자신이 절대로 태어날 수 없을 때만 해당(부모가 있다)



### 코드성 키 엔터티 모델링***(요건 2가지)111

코드는 key entity이다.(부모없음) -> 코드의 종류가 1000개라면, 모두 엔터티로??
아니다. 공통의 코드 entity 3개 정도로 통합한다. 어떤 기준으로 코드를 키엔터티로 따로 빼낼 수 있을까?

**분류코드 같은 속성**을 **`코드성 키 엔터티`**로서 **별도의 엔터티**로 만들어야할까?
단순히 분류만을 위해서라면, 딱히 따로 엔터티로 뺄 필요가 없으나..

1. **자식 엔터티**를 가지면서 & 그 자식과 **다양한 관계**를 가지는 경우111
   ex> 설비TYPE (속성) - 펌프/배관/발전기/압축기/발전기  중  하나를 적어서 분류한다.
         그러나 **설비**가 **공정(자식)**을 **태어나게 한다 **/ 설비가 **없어지면**, 공정도 **없어진다**.
         => **부모가 없는 코드성 키 엔터티로 빼내자!**
2. **자신만의 다양한 속성**을 가지는 경우,111
   ex> 코드 / 코드명 / 코드자격 / 등등 **뒤에 많이 달고 있다면, 따로 엔터티로 빼내자!**
   
   ![](http://cfile9.uf.tistory.com/image/99996F4B5D1E13CF082A03)



### 집합(엔터티의 개체or행위)의 순수성

가. 순수성의 의미

- 개체집합(주체, 목적물)이거나 행위집합(목적물)이거나 둘 중 1개
  - 개체 집합 : 고객, 상품 등
  - 행위 집합 : 입금, 계약
- (순수성 위배) 충돌의 경우 : 
  납입 + 자, 입금 + 자 ==> 행위 + 개체 -> 개체 조회시 3 entity 모두 검색 ===> 사람으로 통합

나. 집합 순수성의 예

- 납입 + 자 : 관계속성 + 고객entity 로 나누어봐야함

**다. 집합 순수성 예외사항**(암기)  ->  **순수성 위배 3가지 111**

- 관계(릴레이션쉽)를 엔터티화 한 것 ex> 피보험+자

  - [고객]---ㅡ<[계약] : 관계가 어마어마하게 많다. 
  - [고객 - **중피보험자1, 중피보험자2, 중피보험자3** ] ---ㅡ<[계약]
  - [고객]**---ㅡ<[보험계약관계자]>ㅡ---**[계약] 으로 많은 관계를 하나의 엔터티로 만들어버린다.

- **부분 집합** 정의 ex> 금융+기관

- 배타적관계 (**아크**)를 없애기 위해 통합해놓은것 ex> 고객,공사현장,물류센터 -(통합)-> 배송처

  ![](http://cfile5.uf.tistory.com/image/99E4003D5D1E165C2274C0)
  고객Entity (부모)  ---- 계약Entity (자식) 사이에서
  **[부모]의 속성**인 **고객 TYPE에 따라 -> [자식]의 속성을 모두 `병렬식`으로 나열**해놓았다.***
  이럴 때는, **`부모TYPE --> 자식이 병렬식 속성들`의 **관계**를 **`중간에 하나의 엔터티로 통합`하여 `직렬식`**으로 만들 수 있다. 
  [부모]의 고객TYPE --->  **[보험계약관계자]의 계약자 구분코드** <--- [계약]의 계약자 고객번호
  ==> 관계를 엔터티화 한 예제이다. 
  ex> 피보험+**자** = **부모의 고객** -- [피보험자] -- 자식의 보험종류

### 집합의 동질성(=통합)

- 정직원만? 협력업체 직원? 아르바이트?  ==> 사원으로 통합
- 개인고객과 법인고객 ==> 고객으로 통합



### 엔터티의 명칭

적절한 엔터티 명칭

- 함축시킨 의미
- 오해를 최소화



### 서브타입(분류 속성)

**가. 서브타입 지정시 고려사항**

- 교집합 허용 불가 ex> [배우 여부] or [가수 여부] --> 배우이면서 가수인 사람 존재
- 합이 전체 집합 ( 배반인 것만 분류속성=서브타입으로 )
- 서브타입 표현의 기준 -> **서브타입 구성 3가지 요건111**
  
  1. **nullable한 선택적 속성이  --> subtype으로 묶으면 필수 속성으로 바뀔 때111**
     ex> [고객 - ..., ,**법인대표자, 법인연락처**, ...] 
     법인대표자, 법인연락처 속성은 subtype이 아니라면, 개인 고객의 데이터가 들어올 때, 선택적 속성일 뿐이다.
     (법인)이라는 sub-type속성 묶으면, (법인-법인대표자, 법인연락처)는 명확하게 필수속성으로 바뀌게 된다.
     =>개인/법인구분(sub-type, 배타적인 값) => 값으로 구분 => 법인 값 들어올 때, 법인대표자, 법인연락처는 sub-type속성(*필수속성)으로 내부에 묶을 수 있다.
     - db는 필수속성, 필수관계를 좋아한다. 선택적 속성, 관계는 싫어한다.
       선택적 속성이 보이면 - subtype으로 만들어주면 좋다.
  
  - **선택적 관계 -> 필수적 관계로 바뀔 때**111
  - **가독성 증진**을 위할 경우111
    ![](http://cfile28.uf.tistory.com/image/99D7D4455D1E1B2B0DC12D)

**나. 서브타입 도출**

1. **분류속성** : 분류속성에 따라서 **엔터티의 정보가 차별화** 되는 경우
2. **`다수`의 선택적 속성**( **소수의 선택적 속성은 오답** ***) : **서브타입 도출시 **필수속성으로 변하는 경우****
3. **선택적 관계가 존재**하는 경우 : 선택적 관계가 -> **필수적 관계로 변하는 경우**
4. 도출 절차
   - 분류 속성 확인 --> 차별화 되는지 확인
   - 분류 속성 값에 의해 분류되는 서브타입 파악
   - 분류 속성에 따라 필수/선택적 분할 정의
   - 서브타입별 속성 할당
   - 슈퍼타입의 관계를 해당 서브타입에 정의
     

**다. 서브타입의 활용**

1. 업무규칙을 명확히 표현하여 이해를 도움
   - 가독성 향상
   - 속성의 선택성이 제거됨 (필수적으로 변해서)
   - 관계의 선택성이 제거됨( 필수적으로 변해서)
2. 서브타입의 표현으로 업무규칙의 **`명확성`과 `복잡성`**은 **트레이드 오프관계** -> **조화**111가 필요
   ex> 요일의/일자 경우, 굳이 서브타입으로 표현안해도 전세계 사람들이 다 이해할 수 있다. 이럴 경우 표현안해도 된다.





### 엔터티 통합과 분할111

통합할수록 유연성은 증가 / 동질성은 감소

현업) **키 엔터티는 통합할려고 함(자식이 명확해지기 때문에)111**. 메인 엔터티는 통합안하려고 한다.

- **집합 동질성 확대를 위한 통합 사례(\*\*\* 암기)111**
  **보험**회사의 **대리점** : 조직이 아니므로 **사원**에 통합시킴
  **통신**회사의 **대리점** : 조직이므로 **조직**에 통합시킴

- **유연성 향상을 위한 통합111(할수록 동질성은 희석된다)111**
  집합의 확장(통합)은 유연성과 단순성 증가 but 지나친 확장은 의미를 희석한다
  *\*\* **상위 엔터티(key entity) 일수록 통합의 효과가 좋다** 
  -> 현업에서는 key는 통합 main은 통합x 할려고함. **이유 : 부모가 명확해진다**
  ex> [개인고객], [법인고객] entity를 따로 나누었다면?  
        하위의 main entity [카드]는 2개의 관계가 개인에서 올수도, 법인에서도 올수도 있다.
        즉, **관계(관계속성)가 베타적인 아크 된다 (cf) 속성의 값(1or2)이 베타적이면? sub-type)** 
  만약, key entity인 개인고객/법인고객이 통합된다면? 부모(부모 2중1이 아닌 1개)가 명확해진다.
  
  ​    -> 상위 엔터티가 분할되어 있다면, join or 의미상의 주어로 부모를 찾아가기 힘듬.

![](http://cfile21.uf.tistory.com/image/998414485D1E1F9103C196)





### **ERD 참고사항** 1) ***

1. 부모-자식관계 : 누가(부모)---> 무엇을(자식)
2. 부모는 2개 까지만! 3개 이상시 4정규형 위배(다치종속?)
3. 선-후 관계 : 점선+실선시 점선이 먼저다!
4. **앞쪽의 점선 시작 : 뒤쪽이 자식아닐 수도**
   **앞쪽의 실선 시작 : 뒤족이 100% 자식가짐**
5. 서브타입의 ?? 여부 : Y / N 만 = Null 없음 => O선택속성이 아니라 *필수속성들로 구성
   ![](http://cfile5.uf.tistory.com/image/996218435D1EE2E92FAD83)
6. **뒤쪽의 점선 : 뒤쪽이 optional이며 ---> O 부모식별자**
   **뒤쪽의 실선 : 뒤쪽이 mandatory이며 ㅡ> * 부모식별자**
   my) **`앞쪽은 자식유뮤  / 뒤에는 부모식별자의 선택성/선택 속성 결정`**
   ![](http://cfile22.uf.tistory.com/image/9917AB405D1EF079101702)